<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络结构</title>
      <link href="/2020/07/14/deeplearning/wang-luo-jie-gou/"/>
      <url>/2020/07/14/deeplearning/wang-luo-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="1-终极目标"><a href="#1-终极目标" class="headerlink" title="1. 终极目标"></a>1. 终极目标</h2><p>类人脑的网络结构和信息处理方式，但更加强大的信息处理能力。</p><p>现状：</p><ul><li>基本的网络块结构已经建立起来</li><li>子网络单元间大致都以线性连接为主（信息传输方式为线性）</li><li>无专门的信息处理单元，应当设置专门的网络结构单元，来处理信息</li></ul><h3 id="1-1-要求"><a href="#1-1-要求" class="headerlink" title="1.1. 要求"></a>1.1. 要求</h3><ul><li>更高的准确率</li><li>更少的参数</li><li>更少的资源消耗</li><li>网络结构应该具备一定的设计原理</li><li>稳定性</li></ul><h3 id="1-2-优化网络质量的生物学原理"><a href="#1-2-优化网络质量的生物学原理" class="headerlink" title="1.2. 优化网络质量的生物学原理"></a>1.2. 优化网络质量的生物学原理</h3><p>基于<strong>赫布原理</strong>和<strong>多尺度处理</strong>。</p><p><strong>赫布原理</strong>：突触前神经元向突触后神经元的<strong>持续重复</strong>的刺激可以导致突触传递效能的增加。赫布理论有下列的特性：</p><ul><li>知觉获知是在神经系统中的表征是一群而不是一个细胞，因此这是一个较为<strong>分散的表征系统</strong>。表征不同的心智活动，并不完全系于细胞的独特身分，因为一个细胞可同时参与几个细胞集团。</li><li>在细胞集合中，无论是组成分子或是联络通路，均有相当程度的<strong>余裕性</strong>，所以容许神经系统有部分的破坏，依然能执行所负担的功能。同时这些平行通路可容许由不同的部位到达兴奋全体的目的。</li><li>细胞集合的成立虽然依赖连结，但连结的成果并非使刺激直通于反应，而是在中枢建立一个有缓冲作用（使刺激的影响能盘桓较久）的回路。</li><li>人的大脑神经元运作的方式的确和原子内粒子的运作方式类似，人类的大脑的确是所有神经网络的总和。每个神经元本身并不重要，重要的是这些神经元怎么联合起来，联合起来可以做些什么事，这才是的细胞集合的核心。</li></ul><blockquote><p><strong>总结</strong>一下：</p><ul><li><strong>每一个表征，都是集体作用的结果</strong>，这一步显然比较容易实现</li><li><strong>个体可以服务于不同集体，即个体间可以组成不同的集体</strong>，即他们之间类似于一个<strong>图结构</strong>，不同的子网络单元之间组成图结构，来控制输出，但应该有有中枢系统，决定调用哪些子网络单元。</li><li>同一子网络单元可以有多个，他们之间为图结构关系，图结构的关联传递，应该可以通过训练来得到，并由中枢系统来控制，也就是在传递过程中要不断地将信号传递会中枢系统，所以应该具有一个完整的信息通道一直处于激活或者待命状态。</li><li>信息传输是否有效，需要有一定判据，在子网络单元内，可以可以通过激活函数，或者权重来衡量（但子网络单元中无效的细胞仍占用了资源），另外可以设置专门的子网络结构来甄别信息是否有效，如果这个过程不需要回到中枢系统判断，那么是否可以设置自中枢系统来甄别。</li><li>信息通道是否设置上行和下行分离</li></ul></blockquote><h3 id="1-3-下一步"><a href="#1-3-下一步" class="headerlink" title="1.3. 下一步"></a>1.3. 下一步</h3><p>目前（CNN中），同一层级内<strong>特征之间的关联</strong>还没有解决，可以通过增加一个或几个特殊通道（甚至是在子网络单元中，增加一个子单元）来表示这一关联特性。显然，这一关联特性也是通过学习得到的。GoogLeNet Inception 最终的concatenate实现了类似的功能，但concatenate后，只是实现了控制输出（其实所有层间都只是实现了控制输出，但类似GoogLeNet Inception这种结构并列细胞的实现更优一些）。应该有一个子单元，来控制开启和关闭一些参数通道，以节省资源。</p><p>不同（细胞或者子网络单元）层级间的传递，不仅是在筛选特征，也在关联这些特征，这是全连接的的表现之一，但是这样无疑会有很多参数会被闲置，但仍占用资源，可以增加一个维度，或者子网络结构来筛选这些特征，更直接的办法就是Dropout或者增加一层网络单元进行筛选，但这并没有解决根本问题，资源占用依旧存在，应该实时的筛选子网络单元中参数或者子网络单元本身。理想的方式是有一个子单元，来控制开启和关闭一些参数通道，以节省资源。</p><p>基于此，了解细胞的种类和每种细胞的特性至关重要，由此我们可以搭建出在不同功能需求下更加优秀子网络单元。自然我们就要了解现有的子网络单元都有哪些特性，从中得到灵感。</p><h2 id="2-网络结构单元子结构-Cell"><a href="#2-网络结构单元子结构-Cell" class="headerlink" title="2. 网络结构单元子结构-Cell"></a>2. 网络结构单元子结构-Cell</h2><h3 id="2-1-Dropout"><a href="#2-1-Dropout" class="headerlink" title="2.1. Dropout"></a>2.1. Dropout</h3><p>全连接–到–稀疏连接–的转换</p><p>减少了不同神经元间的复杂的相互适应，因此它可以使模型被迫获得更加健壮的特征，可以防止过拟合。</p><p>注意区分训练和预测情形Dropout的设置不同。</p><h3 id="2-2-1x1-kernel"><a href="#2-2-1x1-kernel" class="headerlink" title="2.2. 1x1 kernel"></a>2.2. 1x1 kernel</h3><p>将特征交叉重组到不同通道上（其实所有全连接层，都在做这件事，但Pool一类层，并不会增加模型参数），可以用于特征提取和特征增加</p><h3 id="2-3-MaxPool-amp-AveragePool"><a href="#2-3-MaxPool-amp-AveragePool" class="headerlink" title="2.3. MaxPool &amp; AveragePool"></a>2.3. MaxPool &amp; AveragePool</h3><p>特点：不增加训练参数，对特征直接进行筛选或者一视同仁</p><h2 id="3-网络结构单元"><a href="#3-网络结构单元" class="headerlink" title="3. 网络结构单元"></a>3. 网络结构单元</h2><h3 id="3-1-AlexNet"><a href="#3-1-AlexNet" class="headerlink" title="3.1. AlexNet"></a>3.1. AlexNet</h3><p><img src="/public/img/alexnet.jpeg" alt=""></p><p>整个AlexNet网络共12层，为线性结构，包括输入层×1、卷积层×5、池化层×3、全连接层×3，示意图中隐藏了池化层。这个深度很重要:去掉任何卷积层(每个不超过模型参数的1%)都会导致性能表现低下。</p><p><strong>特点：</strong></p><ul><li>激活函数 Relu： 简单，更容易训练，</li><li>Dropout</li></ul><h3 id="3-2-VGG"><a href="#3-2-VGG" class="headerlink" title="3.2. VGG"></a>3.2. VGG</h3><p>虽然AlexNet指明了深度卷积神经网络可以取得出色的结果，但并没有提供简单的规则以指导后来的研究者如何设计新的网络。VGG和AlexNet相比，深度更深，参数更多(1.38亿)，效果和可移植性更好。</p><p>VGG块的组成规律是：连续使用数个相同的填充为1、窗口形状为3×3的卷积层后接上一个步幅为2、窗口形状为2×2的最大池化层。卷积层保持输入的高和宽不变，而池化层则对其减半。</p><p><strong>特点</strong>：</p><ul><li>vgg-block内的卷积层都是同结构的</li><li>池化层都得上一层的卷积层特征缩减一半</li><li>深度较深，参数量够大</li><li>较小的filter size/kernel size： 使得训练参数更少，多次小kernel size比单个大kernel size更具有识别力</li></ul><h3 id="3-3-NetWork-In-Network"><a href="#3-3-NetWork-In-Network" class="headerlink" title="3.3. NetWork In Network"></a>3.3. NetWork In Network</h3><blockquote><p>参考 <a href="https://zhuanlan.zhihu.com/p/108235295" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/108235295</a></p></blockquote><p>Network in Network提出了一种全新的模型设计：用微型网络层MLP代替了传统conv层；用GAP全局平均池化代替了传统的FC层实现分类输出。</p><p><strong>mlp概述</strong>：</p><ol><li>本身和卷积层兼容，且为深度模型，符合特征重用的思想；其中的全连接层等价于1×1卷积。</li><li>为局部特征块提取出更抽象的特征，从而在送入下一层之前，增加抽象性，从而提高模型整体的通用性。</li></ol><p><strong>GAP概述</strong>：</p><ol><li>没有了全连接层，减少了大量需要学习的参数，也降低了FC层过拟合的发生，起到正则化器的效果。</li><li>增强了特征映射和类别之间的对应关系，更符合卷积的结构，因此特征图就更容易对应上最后要输出分类的类别置信度</li></ol><h3 id="3-4-GoogLeNet-Inception"><a href="#3-4-GoogLeNet-Inception" class="headerlink" title="3.4. GoogLeNet Inception"></a>3.4. GoogLeNet Inception</h3><blockquote><p>参考</p><ol><li><a href="https://zhuanlan.zhihu.com/p/108414921" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/108414921</a></li><li><a href="https://my.oschina.net/u/876354/blog/1637819" target="_blank" rel="noopener">https://my.oschina.net/u/876354/blog/1637819</a></li><li><a href="https://zhuanlan.zhihu.com/p/100668087" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/100668087</a></li></ol></blockquote><p><strong>Inception块特点</strong>：</p><ul><li>Inception块之间可以堆叠使用。</li><li>添加了1×1卷积，降低输入的通道维度，避免参数过量影响训练</li><li>多卷积核+池化的并行结构，通过合并层进行串联，实际上让网络具备了自动选择的能力，而不是人为地设置卷积或池化，或决定卷积核的尺寸。</li></ul><p><strong>整个网络深度为22层(参数层共计22层),maxpool池化层5层。还添加了网络中间一些辅助分类器具，这是考虑到由于深度较深，整个模型训练完成可能耗时较长，且浅层网络可能对中间层产生的特征具有较强识别能力，故添加了辅助分类器可以在模型训练的中间阶段就进行分类。</strong>在整个训练过程中，辅助分类器对于损失的以0.3的权重加到总损失中；推断时，辅助网络将被丢弃。</p><p>作者团队借鉴了在Network in Network中使用的1×1卷积，这里的目的有2个，其中最主要的用来降维，通 过降低通道数来削减参数量。这样带来的效果是：同等参数量的模型，可达到更深和更宽。</p><h3 id="ResNet"><a href="#ResNet" class="headerlink" title="ResNet"></a>ResNet</h3><p><strong>网络加深的后果</strong></p><p>在残差块这样的结构引入之前，如果一个神经网络模型的深度太深，可能会带来<strong>梯度消失</strong>和<strong>梯度爆炸</strong>的问题，随着一些<strong>正则化方法</strong>的应用可以缓解此问题，但是随着layer深度的继续加深，又带来了<strong>模型退化</strong>这样的问题。而添加了带shortcut的残差块结构之后，使得整个深度神经网络的层数可以大幅增加，变得更【深】，从而有时会带来更好的训练效果</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>损失函数</title>
      <link href="/2020/06/15/machine-learing/sun-shi-han-shu/"/>
      <url>/2020/06/15/machine-learing/sun-shi-han-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>声明</strong>：<br>本文内容参考了，网络中的一些资源，但时间久远，忘记了出处，所以有些没有指出参考文献。<br>本文也仅作为记录自己学习笔记。若原创觉得有异议请告知。<br>参考资料：</p><ul><li><a href="https://www.cnblogs.com/zongfa/p/9774315.html" target="_blank" rel="noopener">正则化如何防止过拟合</a></li></ul></blockquote><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>在实际应用时，如果样本容量不远远大于样本的特征维度，很可能<strong>造成过拟合</strong>，对这种情况，<br>我们有下面三个<strong>解决方式</strong>：</p><ol><li>加数据</li><li>特征选择（降低特征维度）如 PCA 算法。</li><li>正则化</li><li>训练过程加入验证集<br>validation data的用途很多：<ul><li>根据validation data上的accuracy来确定early stopping的epoch大小</li><li>更新learning rate</li></ul></li></ol><p>过拟合往往是由拟合系数过大导致的。为了拟合样本中每一个点，由于噪声的存在，导致拟合函数波动很大。<br>一般情况下由于自变量的值可大可小，所以只有系数足够大，才能保证倒数值很大，从而拟合函数波动很大，<br>进而就导致了过拟合。</p><p>正则化一般是在损失函数上加入正则化项（表示模型的<strong>复杂度对模型的惩罚</strong>，对系数的惩罚，<br>来约束系数的数目或者大小，所以在一定程度上可以减少过拟合情况），下面我们介绍一般情况下的<br>两种正则化框架。</p><p><strong>问题转变</strong>: 经验风险最小化$\to$ 结构风险最小化</p><p>$$<br>L1: \mathop{argmin}_\omega L(\omega)+\lambda||\omega||_1, \lambda&gt;0<br>$$</p><p>$$<br>L2: \mathop{argmin}_\omega L(\omega)+\alpha||\omega||_2^{2}, \alpha&gt;0<br>$$</p><p>下面对最小二乘误差分别分析这两者的区别。</p><ul><li>L1正则可以引起<strong>稀疏性</strong>$\Longleftrightarrow$L1可以使很多$\omega=0$<ul><li>可以用来做<strong>特征选择</strong></li></ul></li></ul><h3 id="L1-Lasso"><a href="#L1-Lasso" class="headerlink" title="L1 Lasso"></a>L1 Lasso</h3><p>L1正则化可以引起<strong>稀疏解</strong>。</p><p>从最小化损失的角度看，由于 L1 项求导在0附近的左右导数都不是0，因此更容易取到0解。</p><p>从另一个方面看，L1 正则化相当于：</p><p>$$<br>\begin{aligned}<br>&amp; \mathop{argmin}_\omega L(\omega)  \<br>&amp; s.t.||\omega||_1&lt;C<br>\end{aligned}<br>$$</p><p>我们已经看到平方误差损失函数在 $\omega$ 空间是一个菱形，因此上式求解就是菱形和<br>$||\omega||_1=C$ 的切点，因此更容易相切在坐标轴上。</p><p><img src="/img/20160904184428459.png" alt=""></p><p>$$<br>\begin{aligned}<br>\frac{\partial{L}}{\partial{\omega}} &amp; = \lambda sign(\omega)  \<br>\omega &amp; \leftarrow \omega - \eta\frac{\partial{L}}{\omega} = \omega -\eta \lambda sign(\omega)<br>\end{aligned}<br>$$</p><p>每次更新$\omega$，都会减小$\eta\lambda$,经过$N$次迭代后,会有部分$\omega^{i}=0$。</p><h3 id="L2-Ridge"><a href="#L2-Ridge" class="headerlink" title="L2 Ridge"></a>L2 Ridge</h3><p>$$<br>\begin{aligned}<br>\hat{\omega} = \mathop{argmin}_\omega L(\omega) + \lambda\omega^T\omega &amp; \to \frac{\partial}{\partial\omega}L(\omega) +2\lambda\omega = 0  \\<br>&amp; \to 2 X^{T}X\hat{\omega} -2X^TY + 2\lambda\hat{\omega}=0  \\<br>&amp; \to \hat{\omega} = (X^TX+\lambda\mathbb{I})^{-1}X^{T}Y<br>\end{aligned}<br>$$</p><p>$$<br>\omega \leftarrow \omega - \eta\left(\frac{\partial{L}}{\partial{\omega}}+2\lambda\omega\right) = \omega(1-2\eta\lambda) -\eta \frac{\partial{L}}{\partial{\omega}}<br>$$</p><p>每次更新$\omega$，所有都会缩小$1-\eta\lambda$倍,经过$N$次迭代后,所有$\omega^{i}$都会比较小</p><p><strong>岭回归的复杂度</strong><br>这种方法与 普通最小二乘法 的复杂度是相同的.</p><p>可以看到，这个正则化参数和 MAP 结果不谋而合。利用2范数进行正则化不仅可以是模型选择<br>$\omega$较小的参数，同时也避免$X^TX$不可逆的问题。</p><p><img src="/img/20160904184646963.png" alt=""></p><p><strong>如果不太确定用$L_1$好，还是$L_2$好，可以用它们的组合，称作ElasticNet，损失函数如下:</strong><br>$$<br>L(w)=\sum_{i=1}^m(y_i-f(x_i))^2+\lambda||w||_1+\alpha||w||_2<br>$$<br>可以发现通过调整超参，可以控制$w$的大小，如果$\lambda$或$\alpha$设置很大，$w$会被约束的很小，<br>而如果$\alpha$或$\lambda$设置为0，等价于原始的不带正则项的线性回归；通常可以通过交叉验证(Cross-Validation)，<br>根据验证集上的表现来设置一个合适的超参.</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 损失函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode 远程开发</title>
      <link href="/2020/06/09/vs-code/vscode-yuan-cheng-kai-fa-pei-zhi/"/>
      <url>/2020/06/09/vs-code/vscode-yuan-cheng-kai-fa-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="VScode-远程开发配置"><a href="#VScode-远程开发配置" class="headerlink" title="VScode 远程开发配置"></a>VScode 远程开发配置</h1><p>赶在疫情期间，一切似乎都不是那么顺利，不能回到办公室，只能隔离在家，拿着可怜的奋战了多年的14款MBA，实在捉襟见肘。感谢VScode的开发团队，让我的MBA可以再奋战几年，目前正在攒机，弄个高配的台式，一劳永逸。</p><p>参考链接：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/89662757" target="_blank" rel="noopener">知乎韩冰-使用VScode进行远程炼丹</a></li><li><a href="https://zhuanlan.zhihu.com/p/141205262" target="_blank" rel="noopener">「效率」使用VScode连接远程服务器进行开发</a></li></ul><p>感谢两位分享。</p><h3 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h3><p>利用云服务器作为跳板，使得外网<strong>低配</strong>电脑，可以访问内网<strong>高配台式机</strong>。</p><h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><ul><li>VS Code</li><li>云服务器</li></ul><h2 id="购买云服务器"><a href="#购买云服务器" class="headerlink" title="购买云服务器"></a>购买云服务器</h2><p>腾讯云或者阿里云都可以，我这里用的腾讯云，最便宜的1核2线程，10元/月。选择Ubuntu系统。</p><blockquote><p>这里最好重新设置一下用户名和密码，并做一定的保护措施。</p></blockquote><h3 id="安装-VS-Code"><a href="#安装-VS-Code" class="headerlink" title="安装 VS Code"></a>安装 VS Code</h3><p>本地安装 VS code ，安装Remote Development全家桶插件。</p><p>配置<code>~/.ssh/congfig</code></p><pre><code>Host 昵称（起个名字）HostName 服务器ip （例如：127.0.10.8）User 用户名Port 22 （默认为22）</code></pre><p>这样一般就使用VS code访问服务器了。</p><h3 id="设置免密登入"><a href="#设置免密登入" class="headerlink" title="设置免密登入"></a>设置免密登入</h3><p>上述配置后，每次登入还要输入密码，这里可以设置一下ssh免密登入。</p><blockquote><p>设置之后,可以吧密码登入给取消掉，这样更安全。</p></blockquote><ul><li><strong>在本地PC生成ssh公钥和私钥</strong></li></ul><pre><code>ssh-keygen -t rsa</code></pre><p>设置过程中一般直接确认就好，默认设置。</p><ul><li><strong>手动上传公钥文件</strong><br>将本地的公钥文件上传到服务器上，然后在服务器需要免密登录的用户家目录下查看是否有 <code>~/.ssh/authorized_keys</code> 这个文件，<br>如果没有手动创建一个:</li></ul><pre class="line-numbers language-text"><code class="language-text">touch ~/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>然后我们将公钥内容写入到authorized_keys文件中，因为这个文件可能已经有内容了，所以你可以使用如下方式</li></ul><pre class="line-numbers language-text"><code class="language-text">cat -n ~/.ssh/rsa.pub ~/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>将.ssh目录的权限为700</li><li>将authorized_keys目录的权限为600</li></ol><pre class="line-numbers language-text"><code class="language-text">chmod 700 ~/.ssh/chmode 600 ~/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>自动上传本地公钥</strong><br>ssh-copy-id 复制公钥<br>这个工具还蛮有用的，不过它会将我本地的所有公钥都传到服务器，使用方法：</li></ul><pre class="line-numbers language-text"><code class="language-text">ssh-copy-id -p 22 username@remote-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="使用autossh进行内网穿透"><a href="#使用autossh进行内网穿透" class="headerlink" title="使用autossh进行内网穿透"></a>使用autossh进行内网穿透</h3><p>设想这样的场景，你在公司或者学校有一台用于炼丹的服务器，但是只能在内网访问。我在家里使用笔记本也想连接到远程的服务器中，这时我们应该怎么办呢。</p><p>答案是我们需要一台具有公网ip的服务器作为中继，使用autossh将公网服务器作为代理服务器。假设公网服务器为主机A，内网炼丹炉为主机B，我们的笔记本为C则</p><h4 id="主机B上的操作"><a href="#主机B上的操作" class="headerlink" title="主机B上的操作"></a>主机B上的操作</h4><p>将主机B上的公钥拷贝到公网主机C实现B对C的免密登录（具体参考《ssh设置免密登录》），在主机B上执行autossh命令（可以在screen环境下执行）</p><pre class="line-numbers language-console"><code class="language-console">screen -S reverse_proxyautossh -M 5555 -NR 9999:127.0.0.1:9988 -p 22 username@remote-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>-M是公网主机echo的地址，9999是公网服务器的转发端口，第一个22是B主机ssh端口，-p 后面是外网主机ssh端口，最后一个参数是公网主机远程登录地址。使用该命令时保证公网主机5555， 9999端口都是空闲状态。（这两个端口可以改成任意空闲端口）</p><h4 id="主机A上操作"><a href="#主机A上操作" class="headerlink" title="主机A上操作"></a>主机A上操作</h4><p>主机A此时可以直接通过ssh访问公网主机的9999端口访问到B主机的终端，具体操作为</p><pre class="line-numbers language-console"><code class="language-console">ssh -p 9999 username@remote-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证登录成功后，我们在vscode中配置A服务器的ip，和转发端口后就可以连接我们的内网主机了。</p><h3 id="配置-ssh-config"><a href="#配置-ssh-config" class="headerlink" title="配置.ssh/config"></a>配置.ssh/config</h3><pre><code>Host Fish.Tencent    HostName 175.1.0.9    User ubuntu    Port 22Host Fish.Tencent.office    HostName 127.0.0.1    User xxsx    ProxyCommand ssh -W %h:%p -q Fish.Tencent    Port 9988</code></pre><blockquote><p>这一步平不清楚</p><ul><li><strong>这里没有解决jupyter notebook远程服务器连接问题，但是通过内网可以直接访问，说明上面的设置不对</strong></li><li><a href="https://zhuanlan.zhihu.com/p/74193910" target="_blank" rel="noopener">SSH 通过跳板机直接访问内网机器</a>可能可以解决这个问题</li></ul></blockquote><p>最后莫忘了给台式机配个机械硬盘，做每日备份。</p>]]></content>
      
      
      <categories>
          
          <category> VS Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ML的一些Triger</title>
      <link href="/2020/06/06/machine-learing/yi-xie-guan-jian-de-tiger/"/>
      <url>/2020/06/06/machine-learing/yi-xie-guan-jian-de-tiger/</url>
      
        <content type="html"><![CDATA[<h2 id="Triger-1-数据分析"><a href="#Triger-1-数据分析" class="headerlink" title="Triger 1 数据分析"></a>Triger 1 数据分析</h2><p>暂时还不知道什么是Spectral Graph Theory，但对Spectral这个词异常熟悉，打了几年交到了。</p><p>其实拿到数据后，分析数据间的结构和依赖关系很重要，可以尝试构建一个图谱关系，然后，再根据<br>一些特殊链接方式，来提取和传递数据的特征。</p><p>数据间的链接关系（可以用链接矩阵），步长和链接深度。通过训练权重和关联深度，就可以提取出特征建立模型。</p><p>其实很多算法都是在此基础上发展过来的。但发现在算法的处理上其实很多技巧和基本的常用思路，<br>都是前人智慧的结晶，致敬。</p><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><ul><li>Energy</li></ul><h3 id="链接方式-算法"><a href="#链接方式-算法" class="headerlink" title="链接方式|算法"></a>链接方式|算法</h3><ul><li>能量差</li><li>weight sum</li><li>Mean</li><li>MaxPool</li><li>LSTM (Long Short Term Memory)<ul><li>step and depth</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Triger </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据预处理</title>
      <link href="/2020/06/06/deeplearning/shu-ju-yu-chu-li/"/>
      <url>/2020/06/06/deeplearning/shu-ju-yu-chu-li/</url>
      
        <content type="html"><![CDATA[<p>数据的质量至关重要，可能直接决定了模型的预测和泛化能力。它涉及很多因素，包括：准确性、完整性、一致性、时效性、可信性和解释性。</p><p>而现实中我们拿到的数据可能包含了大量的缺失值，可能包含大量的噪音，也可能因为人工录入错误导致有异常存在。</p><p>因此，拿到数据后要对数据进行清洗处理，得到标准的、干净的。连续的数据，供给数据统计或者数据挖掘使用</p><blockquote><p><strong>参考：</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/51131210" target="_blank" rel="noopener">整理一份详细的数据预处理方法</a></li><li><a href="https://zhuanlan.zhihu.com/p/87792056" target="_blank" rel="noopener">最全面的数据预处理介绍</a></li></ul></blockquote><h2 id="1-数据可能存在的问题"><a href="#1-数据可能存在的问题" class="headerlink" title="1. 数据可能存在的问题"></a>1. 数据可能存在的问题</h2><ul><li><p><strong>数据缺失</strong> （Incomplete） 是属性值为空的情况。如 Occupancy = “ ”</p></li><li><p><strong>数据噪声</strong> （Noisy）是数据值不合常理的情况。如 Salary = “-100”</p></li><li><p><strong>数据不一致</strong> （Inconsistent）是数据前后存在矛盾的情况。如 Age = “42” vs. Birthday = “01/09/1985”</p></li><li><p><strong>数据冗余</strong> （Redundant）是数据量或者属性数目超出数据分析需要的情况。</p></li><li><p><strong>数据集不均衡</strong> （Imbalance）是各个类别的数据量相差悬殊的情况。</p></li><li><p><strong>离群点/异常值</strong> （Outliers）是远离数据集中其余部分的数据。</p></li><li><p><strong>数据重复</strong>（Duplicate）是在数据集中出现多次的数据。</p></li></ul><h2 id="2-数据预处理步骤"><a href="#2-数据预处理步骤" class="headerlink" title="2. 数据预处理步骤"></a>2. 数据预处理步骤</h2><p>数据进行预处理主要有以下步骤，第一部分提及的各种脏数据的处理就在这些步骤中完成：</p><ul><li><p><strong>数据清洗</strong> Data Cleansing</p><ul><li><strong>数据集成</strong></li><li><strong>数据规约</strong></li></ul></li><li><p><strong>数据转换</strong> Data Transformation</p><ul><li>采样</li><li>类型转换</li><li>归一化、离散化、稀疏化</li></ul></li><li><p><strong>数据描述</strong> Data Description</p></li><li><p><strong>特征选择</strong> Feature Selection 或特征组合 Feature Combination</p></li><li><p><strong>特征抽取</strong> Feature Extraction</p></li></ul><h3 id="2-1-数据清洗"><a href="#2-1-数据清洗" class="headerlink" title="2.1 数据清洗"></a>2.1 数据清洗</h3><p>这里主要处理第一部分提及的缺失数据、离散点和重复数据</p><h5 id="2-1-1-1-缺失值得处理"><a href="#2-1-1-1-缺失值得处理" class="headerlink" title="2.1.1.1 缺失值得处理"></a>2.1.1.1 缺失值得处理</h5><p><strong>缺失数据有以下几类：</strong></p><p>a.Missing completely at random: <strong>缺失的概率是随机的</strong>，比如门店的计数器因为断电断网等原因在某个时段数据为空。</p><p>b.Missing conditionally at random: <strong>数据是否缺失取决于另外一个属性</strong>，比如一些女生不愿意填写自己的体重。</p><p>c.Not missing at random: <strong>数据缺失与自身的值有关</strong>，比如高收入的人可能不愿意填写收入。</p><p><strong>处理方式有以下几种：</strong></p><ul><li><p><strong>删除变量</strong>：若变量的缺失率较高（大于80%），覆盖率较低，且重要性较低，可以直接将变量删除。</p></li><li><p>定制填充： 工程中常见用-9999进行替代</p></li><li><p><strong>统计量填充</strong>：若缺失率较低（小于95%）且重要性较低，则根据数据分布的情况进行填充。对于数据符合均匀分布，用该变量的均值填补缺失，对于数据存在倾斜分布的情况，采用中位数进行填补。</p></li><li><p>插值法填充：包括随机插值，多重差补法，热平台插补，拉格朗日插值，牛顿插值等</p></li><li><p>模型填充：使用回归、贝叶斯、随机森林、决策树等模型对缺失数据进行预测。</p></li><li><p><strong>哑变量填充</strong>：若变量是离散型，且不同值较少，可转换成哑变量，例如性别SEX变量，存在male,fameal,NA三个不同的值，可将该列转换成 IS_SEX_MALE, IS_SEX_FEMALE, IS_SEX_NA。<em>若某个变量存在十几个不同的值，可根据每个值的频数，将频数较小的值归为一类’other’，降低维度。</em>此做法可最大化保留变量的信息。</p></li></ul><p>总结来看，常用的做法是：先用<code>pandas.isnull.sum()</code>检测出变量的缺失比例，考虑删除或者填充，若需要填充的变量是连续型，一般采用均值法和随机差值进行填充，若变量是离散型，通常采用中位数或哑变量进行填充。</p><p><strong>注意：</strong>若对变量进行分箱离散化，一般会将缺失值单独作为一个箱子（离散变量的一个值）</p><h5 id="2-1-1-2-离群点处理"><a href="#2-1-1-2-离群点处理" class="headerlink" title="2.1.1.2 离群点处理"></a>2.1.1.2 离群点处理</h5><p>异常值是数据分布的常态，处于特定分布区域或范围之外的数据通常被定义为异常或噪声。异常分为两种：“伪异常”，由于特定的业务运营动作产生，是正常反应业务的状态，而不是数据本身的异常；“真异常”，不是由于特定的业务运营动作产生，而是数据本身分布异常，即离群点。主要有以下检测离群点的方法：</p><ul><li><strong>简单统计分析</strong>：根据箱线图、各分位点判断是否存在异常，例如pandas的describe函数可以快速发现异常值。</li><li>$3 \sigma$  原则：若数据存在正态分布，偏离均值的之$3 \sigma$外. 通常定义 $P(|x-\mu|&gt;3\sigma)\le0.003$ 范围内的点为离群点。</li><li><strong>基于绝对离差中位数（MAD）</strong>：这是一种稳健对抗离群数据的距离值方法，采用计算各观测值与平均值的距离总和的方法。放大了离群值的影响。</li><li>基于距离：通过定义对象之间的临近性度量，根据距离判断异常对象是否远离其他对象，缺点是计算复杂度较高，不适用于大数据集和存在不同密度区域的数据集</li><li>基于密度：离群点的局部密度显著低于大部分近邻点，适用于非均匀的数据集</li><li>基于聚类：利用聚类算法，丢弃远离其他簇的小簇。</li><li>在sklearn(一个python机器学习包)中提供了多种方法，如OneClassSVM、Isolation Forest、Local Outlier Factor (LOF)。</li></ul><p>总结来看，在数据处理阶段将离群点作为影响数据质量的异常点考虑，而不是作为通常所说的异常检测目标点，因而楼主一般采用较为简单直观的方法，结合箱线图和MAD的统计方法判断变量的离群点。</p><p>具体的处理手段：</p><ul><li>根据异常点的数量和影响，考虑是否将该条记录删除，信息损失多</li><li>若对数据做了log-scale 对数变换后消除了异常值，则此方法生效，且不损失信息</li><li>平均值或中位数替代异常点，简单高效，信息的损失较少</li><li>在训练树模型时，树模型对离群点的鲁棒性较高，无信息损失，不影响模型训练效果</li></ul><h5 id="2-1-1-3-噪声处理"><a href="#2-1-1-3-噪声处理" class="headerlink" title="2.1.1.3 噪声处理"></a>2.1.1.3 噪声处理</h5><p>噪声是变量的随机误差和方差，是观测点和真实点之间的误差，即 $obs = x+\varepsilon$ 。通常的处理办法：对数据进行分箱操作，等频或等宽分箱，然后用每个箱的平均数，中位数或者边界值（不同数据分布，处理方法不同）代替箱中所有的数，起到平滑数据的作用。另外一种做法是，建立该变量和预测变量的回归模型，根据回归系数和预测变量，反解出自变量的近似值。</p><h5 id="2-1-1-4-重复数据的处理"><a href="#2-1-1-4-重复数据的处理" class="headerlink" title="2.1.1.4 重复数据的处理"></a>2.1.1.4 重复数据的处理</h5><p>如果高度疑似的样本是挨着的，就可以用滑动窗口对比，为了让相似记录相邻，可以每条记录生成一个hash key, 根据key去排序。</p><h4 id="2-1-2-数据集成"><a href="#2-1-2-数据集成" class="headerlink" title="2.1.2 数据集成"></a>2.1.2 数据集成</h4><p>数据分析任务多半涉及数据集成。数据集成将多个数据源中的数据结合成、存放在一个一致的数据存储，如数据仓库中。这些源可能包括多个数据库、数据方或一般文件。</p><ol><li>实体识别问题：例如，数据分析者或计算机如何才能确信一个数 据库中的 <em>customer_id</em> 和另一个数据库中的 <em>cust_number</em> 指的是同一实体?通常，数据库和数据仓库 有元数据——关于数据的数据。这种元数据可以帮助避免模式集成中的错误。</li><li>冗余问题。一个属性是冗余的，如果它能由另一个表“导出”;如年薪。属性或 维命名的不一致也可能导致数据集中的冗余。 用相关性检测冗余：数值型变量可计算相关系数矩阵，标称型变量可计算卡方检验。</li><li>数据值的冲突和处理：不同数据源，在统一合并时，保持规范化，去重。</li></ol><h4 id="2-1-3-数据规约"><a href="#2-1-3-数据规约" class="headerlink" title="2.1.3 数据规约"></a>2.1.3 数据规约</h4><p>数据归约技术可以用来得到数据集的归约表示，它小得多，但仍接近地保持原数据的完整性。 这样，在归约后的数据集上挖掘将更有效，并产生相同(或几乎相同)的分析结果。一般有如下策略：</p><p>1、维度规约</p><p>用于数据分析的数据可能包含数以百计的属性，其中大部分属性与挖掘任务不相关，是冗余的。维度归约通过删除不相关的属性，来减少数据量，并保证信息的损失最小。</p><p><strong>属性子集选择：</strong>目标是找出最小属性集，使得数据类的概率分布尽可能地接近使用所有属性的原分布。在压缩的属性集上挖掘还有其它的优点。它减少了出现在发现模式上的属性的数目，使得模式更易于理解。</p><ul><li>逐步向前选择：该过程由空属性集开始，选择原属性集中最好的属性，并将它添加到该集合中。在其后的每一次迭代，将原属性集剩下的属性中的最好的属性添加到该集合中。</li><li>逐步向后删除：该过程由整个属性集开始。在每一步，删除掉尚在属性集中的最坏属性。</li><li>向前选择和向后删除的结合：向前选择和向后删除方法可以结合在一起，每一步选择一个最 好的属性，并在剩余属性中删除一个最坏的属性。</li></ul><p><code>python scikit-learn</code> 中的递归特征消除算法<code>Recursive feature elimination (RFE)</code>，就是利用这样的思想进行特征子集筛选的，一般考虑建立SVM或回归模型。</p><p><strong>单变量重要性：</strong>分析单变量和目标变量的相关性，删除预测能力较低的变量。这种方法不同于属性子集选择，通常从统计学和信息的角度去分析。</p><ul><li>pearson相关系数和卡方检验，分析目标变量和单变量的相关性。</li><li>回归系数：训练线性回归或逻辑回归，提取每个变量的表决系数，进行重要性排序。</li><li>树模型的Gini指数：训练决策树模型，提取每个变量的重要度，即Gini指数进行排序。</li><li>Lasso正则化：训练回归模型时，加入L1正则化参数，将特征向量稀疏化。</li><li>IV指标：风控模型中，通常求解每个变量的IV值，来定义变量的重要度，一般将阀值设定在0.02以上。</li></ul><p>以上提到的方法，没有讲解具体的理论知识和实现方法，需要自己去熟悉掌握。通常的做法是根据业务需求来定，如果基于业务的用户或商品特征，需要较多的解释性，考虑采用统计上的一些方法，如变量的分布曲线，直方图等，再计算相关性指标，最后去考虑一些模型方法。如果建模需要，则通常采用模型方法去筛选特征，如果用一些更为复杂的GBDT，DNN等模型，建议不做特征选择，而做特征交叉。</p><p>2、维度变换：</p><p>维度变换是将现有数据降低到更小的维度，尽量保证数据信息的完整性。楼主将介绍常用的几种有损失的维度变换方法，将大大地提高实践中建模的效率</p><ul><li>主成分分析（PCA）和因子分析（FA）：PCA通过空间映射的方式，将当前维度映射到更低的维度，使得每个变量在新空间的方差最大。FA则是找到当前特征向量的公因子（维度更小），用公因子的线性组合来描述当前的特征向量。</li><li>奇异值分解（SVD）：SVD的降维可解释性较低，且计算量比PCA大，一般用在稀疏矩阵上降维，例如图片压缩，推荐系统。</li><li>聚类：将某一类具有相似性的特征聚到单个变量，从而大大降低维度。</li><li>线性组合：将多个变量做线性回归，根据每个变量的表决系数，赋予变量权重，可将该类变量根据权重组合成一个变量。</li><li>流行学习：流行学习中一些复杂的非线性方法，可参考skearn：<a href="https://scikit-learn.org/stable/auto_examples/manifold/plot_lle_digits.html" target="_blank" rel="noopener">LLE Example</a></li></ul><h3 id="2-2-数据转换"><a href="#2-2-数据转换" class="headerlink" title="2.2 数据转换"></a>2.2 数据转换</h3><p><strong>在数据转换阶段，我们对数据进行采样处理、类型转换、归一化、离散化、稀疏化处理。</strong></p><h4 id="2-2-1-采样"><a href="#2-2-1-采样" class="headerlink" title="2.2.1 采样"></a>2.2.1 采样</h4><p><strong>采样</strong>是从特定的概率分布中抽取样本点的过程。采样在机器学习中有非常重要的应用：将复杂分布简化为离散的样本点；用重采样可以对样本集进行调整以更好地进行调整并适应后期的模型学习；用于随机模拟以进行复杂模型的近似求解或推理。采样的一个重要作用是处理不均衡数据集。</p><p>最简单的处理不均衡样本集的方法是随机采样。采样一般分为过采样（Over-sampling）和欠采样（Under-sampling）。随机过采样是从少数类样本集 S_min中有放回地随机重复抽取样本，随机欠采样是从多数类样本集S_max中随机选取较少样本。两种方法也存在问题，如随机过采样会扩大数据规模，容易造成过拟合；随机欠采样可能损失部分有用信息，造成欠拟合。为了解决上诉问题，通常在随机过采样时不是简单复制样本，而是采取一定方法生成新的样本。如使用SMOTE（Synthetic Minority Oversampling Technique）算法、Borderline-SMOTE、ADASYN等算法。对于欠采样，可以采用Informed Undersampling来解决数据丢失问题。</p><p>PS：当总体数据量不够时，除了简化模型，我们可以借鉴随机过采样的方法，对每个类进行过采样。具体到图像任务，还可以直接在图像空间进行变换，如可以通过对图像施加一定幅度的变换（旋转、平移、缩放、裁剪、填充、翻转、添加噪声、颜色变换、改变亮度、清晰度、对比度等），得到扩充的数据集。此外，迁移学习也是在小数据集上进行建模的好方法。</p><p>PS：整体准确率不适用于不平衡数据集，需要引入新的度量模式比如<strong>G-mean</strong>, 它会看正类上的准确率，再看负类上的准确率，然后两者相乘取平方根。另外一种常见的度量如<strong>F-score</strong>。</p><h4 id="2-2-2-类型转换"><a href="#2-2-2-类型转换" class="headerlink" title="2.2.2 类型转换"></a>2.2.2 类型转换</h4><p>在<strong>类型转换</strong>处理前，我们先来看下数据的类型。</p><p>数据类型可以简单划分为数值型和非数值型。数值型有连续型和离散型。非数值型有类别型和非类别型，其中类别型特征中如果类别存在排序问题为定序型，若不存在排序问题则为定类型，非类别型是字符串型。如下所示：</p><ul><li><p><strong>连续型 Continuous</strong>  Real values: Temperature, Height, Weight …</p></li><li><p><strong>离散型 Discrete</strong>  Integer values: Number of people …</p></li><li><p><strong>定序型 Ordinal</strong>  Rankings: {Average, Good, Best}, {Low, Medium, High} …</p><p>对于定序型，我们可以使用<strong>序号编码</strong>，如成绩，分为Average, Good, Best三档，序号编码可以按照大小关系对定序型特征赋予一个数值ID，例如Average表示为1，Good表示为2，Best表示为3，转换后依旧保留了大小关系。</p></li><li><p><strong>定类型 Nominal</strong>  Symbols: {Teacher, Worker, Salesman}, {Red, Green, Blue} …</p><p>对于定类型，我们可以使用<strong>独热编码</strong>，如颜色三原色，为Red, Green, Blue，独热编码可以把三原色变为一个三维稀疏向量，Red表示为（0，0，1），Green表示为（0，1，0），Blue表示为（1，0，0）。需要注意的是，在类别值较多的情况下，可以使用稀疏向量来节省空间，目前大部分算法实现均接受稀疏向量形式的输入。当然还有很多别的编码方式，如二进制编码等，感兴趣的可以额外查阅资料了解。</p></li><li><p><strong>字符串型 String</strong>  Text: “Tsinghua University”, “No. 123, Pingan Avenue” …</p><p>对于字符串型，我们有多种表示方式，如<strong>词袋模型（Bag of Words）</strong>，<strong>TF-IDF（Term Frequency-Inverse）</strong>，<strong>主题模型（Topic Model）</strong>，<strong>词嵌入模型（Word Embedding）</strong>。各种表示有不同的适用场景和优缺点，需要进一步了解的可以额外查资料。</p></li><li><p>对于非数值型，我们需要进行类别转换，即将非数值型转换为数值型，以方便机器学习算法后续处理。</p></li></ul><h4 id="2-2-3-归一化处理"><a href="#2-2-3-归一化处理" class="headerlink" title="2.2.3 归一化处理"></a>2.2.3 归一化处理</h4><p>经过类别转换后，我们所有的数据均转为了数值型。为了消除数据特征之间的量纲影响，我们需要对特征进行<strong>归一化</strong>处理，使不同指标之间具有可比性。</p><p><strong>规范化处理：</strong>数据中不同特征的量纲可能不一致，数值间的差别可能很大，不进行处理可能会影响到数据分析的结果，因此，需要对数据按照一定比例进行缩放，使之落在一个特定的区域，便于进行综合分析。特别是基于距离的挖掘方法，聚类，KNN，SVM一定要做规范化处理。</p><ul><li>最大 - 最小规范化：将数据映射到[0,1]区间， $x_{new}=\frac{x-x_{min}}{x_{max}-x_{min}}$</li></ul><ul><li>Z-Score标准化：处理后的数据均值为0，方差为1， $x_{new}=\frac{x-\overline{x}}{\sigma}$</li></ul><ul><li>Log变换：在时间序列数据中，对于数据量级相差较大的变量，通常做Log函数的变换， $x_{new}=\log x$ .</li></ul><p><strong>离散化处理：</strong>数据离散化是指将连续的数据进行分段，使其变为一段段离散化的区间。分段的原则有基于等距离、等频率或优化的方法。数据离散化的原因主要有以下几点：</p><ul><li>模型需要：比如决策树、朴素贝叶斯等算法，都是基于离散型的数据展开的。如果要使用该类算法，必须将离散型的数据进行。有效的离散化能减小算法的时间和空间开销，提高系统对样本的分类聚类能力和抗噪声能力。</li><li>离散化的特征相对于连续型特征更易理解。</li><li>可以有效的克服数据中隐藏的缺陷，使模型结果更加稳定。</li></ul><p>等频法：使得每个箱中的样本数量相等，例如总样本n=100，分成k=5个箱，则分箱原则是保证落入每个箱的样本量=20。</p><p>等宽法：使得属性的箱宽度相等，例如年龄变量（0-100之间），可分成 [0,20]，[20,40]，[40,60]，[60,80]，[80,100]五个等宽的箱。</p><p>聚类法：根据聚类出来的簇，每个簇中的数据为一个箱，簇的数量模型给定。</p><p><strong>稀疏化处理：</strong>针对离散型且标称变量，无法进行有序的LabelEncoder时，通常考虑将变量做0，1哑变量的稀疏化处理，例如动物类型变量中含有猫，狗，猪，羊四个不同值，将该变量转换成<code>is_猪，is_猫，is_狗，is_羊</code>四个哑变量。若是变量的不同值较多，则根据频数，将出现次数较少的值统一归为一类’rare’。稀疏化处理既有利于模型快速收敛，又能提升模型的抗噪能力。</p><h3 id="2-3-数据描述"><a href="#2-3-数据描述" class="headerlink" title="2.3 数据描述"></a>2.3 数据描述</h3><p><strong>在数据描述阶段，我们可以根据需要计算统计量和对数据进行可视化。</strong></p><p>数据的一般性描述有<strong>mean</strong>, <strong>median</strong>, <strong>mode</strong>, <strong>variance</strong>.</p><p>mean是均值；median是中位数，取数据排序后在中间位置的值，避免因为极端离群点影响客观评价；mode是出现频率最高的元素，其实用的比较少；variance是方差衡量数据集与其均值的偏离。</p><p>数据之间的相关性可以使用<strong>Pearson correlation coefficient和Pearson chi-square</strong>进行度量。前者适用与有metric data的情况，后者适用于分类统计的情况。</p><p><strong>数据可视化</strong>一维数据圆饼图，柱状图；二维数据散点图；三维数据用三维坐标呈现；高维数据需要先做转换或映射，比如用matlab的Box Plots，也可以用平行坐标呈现。可使用工具有很多，如matlab和Geph。</p><h3 id="2-4-特征选择"><a href="#2-4-特征选择" class="headerlink" title="2.4 特征选择"></a>2.4 特征选择</h3><p>参见[数据规约]</p><p>当我们做特定分析的时候，可能属性非常多，但有些属性是不相关的，有些属性是重复的，所以我们需要用<strong>特征选择</strong>挑选出来最相关的属性降低问题难度。</p><p>我们可以通过熵增益(Entropy Information Gain)、分支定界（Branch and Bound）等方式进行特征选择。特征选择还有sequential forward, sequential backward, simulated annealing(模拟退火), tabu search(竞技搜索), genetic algorithms(遗传算法)等方式去优化。</p><p>为了提高复杂关系的拟合能力，在特征工程中经常会把一些离散特征两两<strong>组合</strong>，构成高阶特征。如在点击率预测问题中，原始数据有语言和类型两种特征，为了提高拟合能力，语言和类型可以组合成二阶特征，联合预测对点击率的影响。如何找到有意义的组合特征？有一种方法是基于决策树的组合特征寻找方法。</p><p>在机器学习中，数据通常需要表示为向量的形式进行训练，但是在对高维向量进行处理和分析时，会极大消耗系统资源，甚至产生维度灾难。因此，使用低维度的向量来表示高维度的向量就十分必要。<strong>特征抽取或降维</strong>即使用低纬度向量表示高维度向量的方法。</p><p><strong>特征抽取是</strong>主要有主成分分析（Principal Component Analysis，PCA）和线性判别分析（Linear Discriminant Analysis，LDA）两种方式。两者相同之处为均假设数据服从高斯分布，都使用了矩阵分解的思想。两者不同之处为PCA是无监督的算法，对降低后的维度无限制，其目标为投影方差最大；LDA是有监督的算法，降维后的维度小于类别数，其目标为类内方差最小，类间方差最大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>以上介绍了数据预处理中会用到的大部分方法和技术，完全适用于初学者学习掌握，并且对于实践建模会有大幅度提升。以上方法的代码实现，均可在python的pandas和sklearn中完成。大家可根据需要去查阅学习，网上资料也很多，楼主只提供方法和经验上的借鉴，希望每个认真学习巩固的同学都能得到提升。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TensorFlow 2.0 Notes</title>
      <link href="/2020/06/06/deeplearning/tf2-notes/"/>
      <url>/2020/06/06/deeplearning/tf2-notes/</url>
      
        <content type="html"><![CDATA[<p>这篇文章，主要在于记录，自己对TensorFlow这个框架的不断理解的过程。记载了一些认为有必要，写下来提醒自己的问题或者方法，也方便日后自己查阅。</p><h2 id="1-Tensorflow-中的运算符操作"><a href="#1-Tensorflow-中的运算符操作" class="headerlink" title="1. Tensorflow 中的运算符操作"></a>1. Tensorflow 中的运算符操作</h2><ul><li>运算符只支持同类型数据操作<br>这是运算速度的保障</li><li>类型变换可以通过<code>tf.cast(x, dtype, name=None)</code><br>外部操作，不改变，原变量，有返回值</li><li><code>Variable</code> 变量重新赋值，可以调用<code>x.assign()</code><br>在手动更新变量时，比较实用。</li></ul><pre class="line-numbers language-python"><code class="language-python">lr <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>x <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tape<span class="token punctuation">:</span>    y <span class="token operator">=</span> tf<span class="token punctuation">.</span>square<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    loss <span class="token operator">=</span> tf<span class="token punctuation">.</span>square<span class="token punctuation">(</span>y<span class="token number">-3</span><span class="token punctuation">)</span>grads <span class="token operator">=</span> tape<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>loss<span class="token punctuation">,</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>x<span class="token punctuation">.</span>assign<span class="token punctuation">(</span>x<span class="token operator">-</span>lr<span class="token operator">*</span>grads<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-数据操作"><a href="#2-数据操作" class="headerlink" title="2. 数据操作"></a>2. 数据操作</h2><blockquote><p>参考： <a href="https://lyhue1991.github.io/eat_tensorflow2_in_30_days/5-1,%E6%95%B0%E6%8D%AE%E7%AE%A1%E9%81%93Dataset.html" target="_blank" rel="noopener">30天吃掉TensorFlow2</a></p></blockquote><p>可以通过<code>Numpy Array</code>、<code>Pandas DataFrame</code>、<code>tf.data.Dataset</code>，具体的应用和优缺点，还是不清楚。</p><h3 id="2-1-Numpy-array"><a href="#2-1-Numpy-array" class="headerlink" title="2.1. Numpy array"></a>2.1. Numpy array</h3><p>可以直接用于<code>model.fit</code>,还不明白其具体的处理流程</p><h3 id="2-2-数据转换-tf-data-Dataset"><a href="#2-2-数据转换-tf-data-Dataset" class="headerlink" title="2.2. 数据转换 tf.data.Dataset"></a>2.2. 数据转换 <code>tf.data.Dataset</code></h3><p><code>Dataset</code>数据结构应用非常灵活，因为它本质上是一个<code>Sequece序列</code>，其每个元素可以是各种类型，例如可以是张量，列表，字典，也可以是Dataset。</p><h4 id="2-2-1-Source-Datasets"><a href="#2-2-1-Source-Datasets" class="headerlink" title="2.2.1. Source Datasets"></a>2.2.1. Source Datasets</h4><ul><li>simplest way<br>  <code>tf.data.Dataset.from_tensor_slice()</code></li><li>Process lines from files<br>  <code>tf.data.TextLineDataset([&#39;file1.txt&#39;, &#39;file2.txt&#39;])</code></li><li>process records written in the <code>TFRecord</code> format<br>  <code>tf.data.TFRecordDataset([&#39;file1.tfrecords&#39;, &#39;file2.tfrecords&#39;])</code></li></ul><h4 id="2-2-2-Transformations"><a href="#2-2-2-Transformations" class="headerlink" title="2.2.2. Transformations"></a>2.2.2. Transformations</h4><p><code>Dataset</code>包含了非常丰富的数据转换功能。这些方法还都是很有意思的。</p><ul><li>map: 将转换函数映射到数据集每一个元素。</li><li>flat_map: 将转换函数映射到数据集的每一个元素，并将嵌套的Dataset压平。</li><li>interleave: 效果类似flat_map,但可以将不同来源的数据夹在一起。</li><li>filter: 过滤掉某些元素。</li><li>zip: 将两个长度相同的Dataset横向铰合。</li><li>concatenate: 将两个Dataset纵向连接。</li><li>reduce: 执行归并操作。</li><li>batch : 构建批次，每次放一个批次。比原始数据增加一个维度。 其逆操作为unbatch。</li><li>padded_batch: 构建批次，类似batch, 但可以填充到相同的形状。</li><li>window :构建滑动窗口，返回Dataset of Dataset.</li><li>shuffle: 数据顺序洗牌。</li><li>repeat: 重复数据若干次，不带参数时，重复无数次。</li><li>shard: 采样，从某个位置开始隔固定距离采样一个元素。</li><li>take: 采样，从开始位置取前几个元素。</li></ul><blockquote><p>注意，shuffle函数操作流程</p><ul><li>顺序导入到大小为buffer_size的数据池，并打乱顺序</li><li>提走batch_size个数据</li><li>顺序导入数据集中batch_size个数据，并打乱顺序</li></ul></blockquote><h4 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能</h4><p><a href="https://lyhue1991.github.io/eat_tensorflow2_in_30_days/5-1,%E6%95%B0%E6%8D%AE%E7%AE%A1%E9%81%93Dataset.html" target="_blank" rel="noopener">参考这里</a></p><p>训练深度学习模型常常会非常耗时。</p><p>模型训练的耗时主要来自于两个部分，一部分来自<strong>数据准备</strong>，另一部分来自<strong>参数迭代</strong>。</p><p>参数迭代过程的耗时通常依赖于GPU来提升。</p><p>而数据准备过程的耗时则可以通过构建高效的数据管道进行提升。</p><p>以下是一些构建高效数据管道的建议。</p><ol><li>使用 <code>prefetch</code> 方法让数据准备和参数迭代两个过程相互并行。</li><li>使用 <code>interleave</code> 方法可以让数据读取过程多进程执行,并将不同来源数据夹在一起。</li><li>使用 <code>map</code> 时设置<code>num_parallel_calls</code> 让数据转换过程多进行执行。</li><li>使用 <code>cache</code> 方法让数据在第一个<code>epoch</code>后缓存到内存中，仅限于数据集不大情形。<strong>慎用：数据小时可以，数据很大，内存会爆</strong></li><li>使用 <code>map</code>转换时，先<code>batch</code>, 然后采用向量化的转换方法对每个<code>batch</code>进行转换。</li></ol><p>示例1</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 构建管道</span><span class="token keyword">def</span> <span class="token function">parse_line</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">:</span>    t <span class="token operator">=</span> tf<span class="token punctuation">.</span>strings<span class="token punctuation">.</span>split<span class="token punctuation">(</span>line<span class="token punctuation">,</span><span class="token string">"\t"</span><span class="token punctuation">)</span>    label <span class="token operator">=</span> tf<span class="token punctuation">.</span>reshape<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>cast<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>strings<span class="token punctuation">.</span>to_number<span class="token punctuation">(</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>tf<span class="token punctuation">.</span>int32<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    features <span class="token operator">=</span> tf<span class="token punctuation">.</span>cast<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>strings<span class="token punctuation">.</span>to_number<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>strings<span class="token punctuation">.</span>split<span class="token punctuation">(</span>t<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>tf<span class="token punctuation">.</span>int32<span class="token punctuation">)</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>features<span class="token punctuation">,</span>label<span class="token punctuation">)</span>ds_train<span class="token operator">=</span>  tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>TextLineDataset<span class="token punctuation">(</span>filenames <span class="token operator">=</span> <span class="token punctuation">[</span>train_token_path<span class="token punctuation">]</span><span class="token punctuation">)</span> \   <span class="token punctuation">.</span>map<span class="token punctuation">(</span>parse_line<span class="token punctuation">,</span>num_parallel_calls <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>AUTOTUNE<span class="token punctuation">)</span> \   <span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>buffer_size <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>batch<span class="token punctuation">(</span>BATCH_SIZE<span class="token punctuation">)</span> \   <span class="token punctuation">.</span>prefetch<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>AUTOTUNE<span class="token punctuation">)</span>ds_test<span class="token operator">=</span>  tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>TextLineDataset<span class="token punctuation">(</span>filenames <span class="token operator">=</span> <span class="token punctuation">[</span>test_token_path<span class="token punctuation">]</span><span class="token punctuation">)</span> \   <span class="token punctuation">.</span>map<span class="token punctuation">(</span>parse_line<span class="token punctuation">,</span>num_parallel_calls <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>AUTOTUNE<span class="token punctuation">)</span> \   <span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>buffer_size <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>batch<span class="token punctuation">(</span>BATCH_SIZE<span class="token punctuation">)</span> \   <span class="token punctuation">.</span>prefetch<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>AUTOTUNE<span class="token punctuation">)</span>ds_train_raw <span class="token operator">=</span>  tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>TextLineDataset<span class="token punctuation">(</span>filenames <span class="token operator">=</span> <span class="token punctuation">[</span>train_data_path<span class="token punctuation">]</span><span class="token punctuation">)</span> \   <span class="token punctuation">.</span>map<span class="token punctuation">(</span>split_line<span class="token punctuation">,</span>num_parallel_calls <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>AUTOTUNE<span class="token punctuation">)</span> \   <span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>buffer_size <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>batch<span class="token punctuation">(</span>BATCH_SIZE<span class="token punctuation">)</span> \   <span class="token punctuation">.</span>prefetch<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>AUTOTUNE<span class="token punctuation">)</span>ds_test_raw <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>TextLineDataset<span class="token punctuation">(</span>filenames <span class="token operator">=</span> <span class="token punctuation">[</span>test_data_path<span class="token punctuation">]</span><span class="token punctuation">)</span> \   <span class="token punctuation">.</span>map<span class="token punctuation">(</span>split_line<span class="token punctuation">,</span>num_parallel_calls <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>AUTOTUNE<span class="token punctuation">)</span> \   <span class="token punctuation">.</span>batch<span class="token punctuation">(</span>BATCH_SIZE<span class="token punctuation">)</span> \   <span class="token punctuation">.</span>prefetch<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>AUTOTUNE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>示例2</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#使用并行化预处理num_parallel_calls 和预存数据prefetch来提升性能</span>ds_train <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>list_files<span class="token punctuation">(</span><span class="token string">"./data/cifar2/train/*/*.jpg"</span><span class="token punctuation">)</span> \           <span class="token punctuation">.</span>map<span class="token punctuation">(</span>load_image<span class="token punctuation">,</span> num_parallel_calls<span class="token operator">=</span>tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>AUTOTUNE<span class="token punctuation">)</span> \           <span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span>buffer_size <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>batch<span class="token punctuation">(</span>BATCH_SIZE<span class="token punctuation">)</span> \           <span class="token punctuation">.</span>prefetch<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>AUTOTUNE<span class="token punctuation">)</span>ds_test <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>list_files<span class="token punctuation">(</span><span class="token string">"./data/cifar2/test/*/*.jpg"</span><span class="token punctuation">)</span> \           <span class="token punctuation">.</span>map<span class="token punctuation">(</span>load_image<span class="token punctuation">,</span> num_parallel_calls<span class="token operator">=</span>tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>AUTOTUNE<span class="token punctuation">)</span> \           <span class="token punctuation">.</span>batch<span class="token punctuation">(</span>BATCH_SIZE<span class="token punctuation">)</span> \           <span class="token punctuation">.</span>prefetch<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>experimental<span class="token punctuation">.</span>AUTOTUNE<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-Gradient-操作"><a href="#3-Gradient-操作" class="headerlink" title="3. Gradient 操作"></a>3. Gradient 操作</h2><ul><li>非高阶函数全连接操作都必须在Gradient的tape中完成？</li></ul><pre class="line-numbers language-python"><code class="language-python">lr <span class="token operator">=</span> tf<span class="token punctuation">.</span>constant<span class="token punctuation">(</span><span class="token number">1e</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span>x <span class="token operator">=</span> tf<span class="token punctuation">.</span>Variable<span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tape<span class="token punctuation">:</span>    y <span class="token operator">=</span> tf<span class="token punctuation">.</span>square<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 这两行必须在tape中</span>    loss <span class="token operator">=</span> tf<span class="token punctuation">.</span>square<span class="token punctuation">(</span>y<span class="token number">-3</span><span class="token punctuation">)</span>grads <span class="token operator">=</span> tape<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>loss<span class="token punctuation">,</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 不然这一步，不能识别x为loss的变量</span>x<span class="token punctuation">.</span>assign<span class="token punctuation">(</span>x<span class="token operator">-</span>lr<span class="token operator">*</span>grads<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>由于梯度运算会消耗大量的计算资源，而且会自动更新相关参数，对于不需要的优化的张量，如神经网络的输入𝑿， 不需要通过 <code>tf.Variable</code> 封装;相反，对于需要计算梯度并优化的张量，如神经网络层的𝑾 和𝒃，需要通过 <code>tf.Variable</code> 包裹以便 <code>TensorFlow</code> 跟踪相关梯度信息。</p></blockquote><h2 id="4-模型建立"><a href="#4-模型建立" class="headerlink" title="4. 模型建立"></a>4. 模型建立</h2><h3 id="4-1-样例"><a href="#4-1-样例" class="headerlink" title="4.1. 样例"></a>4.1. 样例</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Model</span><span class="token punctuation">(</span>tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>Model<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>Model<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 这样做貌似更符合规范</span>    <span class="token keyword">def</span> <span class="token function">build</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> input_shape<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token triple-quoted-string string">'''        input_shape = (None, n_variable): 变量维度+1        '''</span>        self<span class="token punctuation">.</span>dense1 <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span>units<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">,</span> activation<span class="token operator">=</span>tf<span class="token punctuation">.</span>nn<span class="token punctuation">.</span>relu<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>dense2 <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span>units<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>        super<span class="token punctuation">(</span>Model<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>build<span class="token punctuation">(</span>input_shape<span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">call</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> inputs<span class="token punctuation">)</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> self<span class="token punctuation">.</span>dense1<span class="token punctuation">(</span>inputs<span class="token punctuation">)</span>        outputs <span class="token operator">=</span> self<span class="token punctuation">.</span>dense2<span class="token punctuation">(</span>x<span class="token punctuation">)</span>        <span class="token keyword">return</span> outputs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-关闭session"><a href="#4-2-关闭session" class="headerlink" title="4.2. 关闭session"></a>4.2. 关闭session</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">App</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">train</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">predict</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>     <span class="token keyword">def</span> <span class="token function">valid</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>    <span class="token keyword">def</span> <span class="token function">close</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>clear_session<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">def</span> <span class="token function">__enter__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># with 语句执行</span>        <span class="token keyword">return</span> self        <span class="token keyword">def</span> <span class="token function">__exit__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> exc_type<span class="token punctuation">,</span> exc_val<span class="token punctuation">,</span> exc_tb<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>app <span class="token operator">=</span> App<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">with</span> app<span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># __enter__ 语句</span>    app<span class="token punctuation">.</span>train<span class="token punctuation">(</span><span class="token punctuation">)</span>    app<span class="token punctuation">.</span>predict<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-TensorBoard"><a href="#5-TensorBoard" class="headerlink" title="5. TensorBoard"></a>5. TensorBoard</h2><blockquote><p>参考 <a href="https://tensorflow.google.cn/tensorboard/get_started" target="_blank" rel="noopener">TensorBoard官网</a><br>写的很详细了，这部分内容与管网基本一致，建议直接看官方英文文档。</p></blockquote><h3 id="5-1-通过-Keras-Model-fit-使用-TensorBoard"><a href="#5-1-通过-Keras-Model-fit-使用-TensorBoard" class="headerlink" title="5.1. 通过 Keras Model.fit() 使用 TensorBoard"></a>5.1. 通过 Keras Model.fit() 使用 TensorBoard</h3><p>当使用 <code>Keras&#39;s Model.fit()</code> 函数进行训练时, 添加 <code>tf.keras.callback.TensorBoard</code> 回调</p><ul><li>确保创建和存储日志</li><li>enable histogram computation every epoch with histogram_freq=1 (this is off by default)</li></ul><p>首先导入数据，这里以MNIST为例。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 注意这里x_train.shape=[None,28,28]数组</span><span class="token punctuation">(</span>x_tain<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span> <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>datasets<span class="token punctuation">.</span>mnist<span class="token punctuation">.</span>load_data<span class="token punctuation">(</span><span class="token punctuation">)</span>x_train<span class="token punctuation">,</span> x_test  <span class="token operator">=</span> x_train<span class="token operator">/</span><span class="token number">255.0</span><span class="token punctuation">,</span> x_test<span class="token operator">/</span><span class="token number">255.0</span><span class="token keyword">def</span> <span class="token function">create_model</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>Sequential<span class="token punctuation">(</span><span class="token punctuation">[</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Flatten<span class="token punctuation">(</span>input_shape<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true"># 注意这里input_shape</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">512</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'relu'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dropout<span class="token punctuation">(</span><span class="token number">0.2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>layers<span class="token punctuation">.</span>Dense<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> activation<span class="token operator">=</span><span class="token string">'softmax'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python"><code class="language-python">model <span class="token operator">=</span> create_model<span class="token punctuation">(</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>compile<span class="token punctuation">(</span>optimizer<span class="token operator">=</span><span class="token string">'adam'</span><span class="token punctuation">,</span>              loss<span class="token operator">=</span><span class="token string">'sparse_categorical_crossentropy'</span><span class="token punctuation">,</span>              metrics<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'accuracy'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 这一步必须率先定义,还有很多参数</span>log_dir <span class="token operator">=</span> <span class="token string">"logs/fit/"</span> <span class="token operator">+</span> datetime<span class="token punctuation">.</span>datetime<span class="token punctuation">.</span>now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">"%Y%m%d-%H%M%S"</span><span class="token punctuation">)</span>tensorboard_callback <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>callbacks<span class="token punctuation">.</span>TensorBoard<span class="token punctuation">(</span>log_dir<span class="token operator">=</span>log_dir<span class="token punctuation">,</span> histogram_freq<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>model<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x<span class="token operator">=</span>x_train<span class="token punctuation">,</span>           y<span class="token operator">=</span>y_train<span class="token punctuation">,</span>           epochs<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span>           validation_data<span class="token operator">=</span><span class="token punctuation">(</span>x_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span><span class="token punctuation">,</span>           callbacks<span class="token operator">=</span><span class="token punctuation">[</span>tensorboard_callback<span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-tf-GradientTape-and-tf-summary"><a href="#5-2-tf-GradientTape-and-tf-summary" class="headerlink" title="5.2. tf.GradientTape() and tf.summary"></a>5.2. <code>tf.GradientTape()</code> and <code>tf.summary</code></h3><p>官网这部分写了一个很完整的训练模型，对于初学者而言很友好。从例子中也可以学到一些，处理流程和方法。</p><p>首先还是数据部分，这里就很有意思了，对于非计算机的同学而言，这简直是新世界，对象还可以这样玩儿。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 这里两个dataset对象，设计的很有意思，可以探究一下</span>train_dataset <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Data<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span><span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token punctuation">)</span>test_dataset <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Data<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span><span class="token punctuation">(</span>x_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 这一步就很有意思，这几个方法定义的巧妙</span>train_dataset <span class="token operator">=</span> train_dataset<span class="token punctuation">.</span>shuffle<span class="token punctuation">(</span><span class="token number">600000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>batch<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span>test_dataset <span class="token operator">=</span> test_dataset<span class="token punctuation">.</span>batch<span class="token punctuation">(</span><span class="token number">64</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来定义<code>log metrics</code> 和 <code>optimizer</code></p><pre class="line-numbers language-python"><code class="language-python">loss_object <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>loss<span class="token punctuation">.</span>SparseCategoricalCrossentropy<span class="token punctuation">(</span><span class="token punctuation">)</span>optimizer <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>optimizer<span class="token punctuation">.</span>Adam<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 用来记录mertics</span>train_loss <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>metrics<span class="token punctuation">.</span>Mean<span class="token punctuation">(</span><span class="token string">'train_loss'</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>train_accuracy <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>metrics<span class="token punctuation">.</span>SparseCategoriesAccuracy<span class="token punctuation">(</span><span class="token string">'train_accuracy'</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>test_loss <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>metrics<span class="token punctuation">.</span>Mean<span class="token punctuation">(</span><span class="token string">'test_loss'</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>float32<span class="token punctuation">)</span>test_accuracy <span class="token operator">=</span> tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>metrics<span class="token punctuation">.</span>SparseCategoriesAccuracy<span class="token punctuation">(</span><span class="token string">'test_accuracy'</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>tf<span class="token punctuation">.</span>float32<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义training 和test 函数</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">train_step</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> optimizer<span class="token punctuation">,</span> x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">with</span> tf<span class="token punctuation">.</span>GradientTape<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tape<span class="token punctuation">:</span>        predictions <span class="token operator">=</span> model<span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> training<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>        loss <span class="token operator">=</span> loss_object<span class="token punctuation">(</span>y_train<span class="token punctuation">,</span> predictions<span class="token punctuation">)</span>    grads <span class="token operator">=</span> tape<span class="token punctuation">.</span>gradient<span class="token punctuation">(</span>loss<span class="token punctuation">,</span> model<span class="token punctuation">.</span>trainable_variables<span class="token punctuation">)</span>    optimizer<span class="token punctuation">.</span>apply_gradients<span class="token punctuation">(</span>zip<span class="token punctuation">(</span>grads<span class="token punctuation">,</span> model<span class="token punctuation">.</span>trainable_variables<span class="token punctuation">)</span><span class="token punctuation">)</span>    train_loss<span class="token punctuation">(</span>loss<span class="token punctuation">)</span>    train_accuracy<span class="token punctuation">(</span>y_train<span class="token punctuation">,</span> predictions<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">test_step</span><span class="token punctuation">(</span>model<span class="token punctuation">,</span> x_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span><span class="token punctuation">:</span>    predictions <span class="token operator">=</span> model<span class="token punctuation">(</span>x_test<span class="token punctuation">)</span>    loss <span class="token operator">=</span> loss_object<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> predictions<span class="token punctuation">)</span>    test_loss<span class="token punctuation">(</span>loss<span class="token punctuation">)</span>    test_accuracy<span class="token punctuation">(</span>y_test<span class="token punctuation">,</span> predictions<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来关键设置<code>tf.summary</code></p><pre class="line-numbers language-python"><code class="language-python">current_time <span class="token operator">=</span> datatime<span class="token punctuation">.</span>datatime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strftime<span class="token punctuation">(</span><span class="token string">'%Y%m%d-%H%M%S'</span><span class="token punctuation">)</span>train_log_dir <span class="token operator">=</span> <span class="token string">'logs/gradient_tape/'</span><span class="token operator">+</span>current_time<span class="token operator">+</span><span class="token string">'/train'</span>test_log_dir <span class="token operator">=</span> <span class="token string">'logs/gradient_tape/'</span><span class="token operator">+</span>current_time<span class="token operator">+</span><span class="token string">'/test'</span>train_summary_writer <span class="token operator">=</span> tf<span class="token punctuation">.</span>summary<span class="token punctuation">.</span>create_file_write<span class="token punctuation">(</span>train_log_dir<span class="token punctuation">)</span>test_summary_writer <span class="token operator">=</span> tf<span class="token punctuation">.</span>summary<span class="token punctuation">.</span>create_file_write<span class="token punctuation">(</span>test_log_dir<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在training和test中，利用<code>tf.summary.scalar()</code>将metrics(loss，accuracy)写入log。</p><pre class="line-numbers language-python"><code class="language-python">model <span class="token operator">=</span> create_model<span class="token punctuation">(</span><span class="token punctuation">)</span>EPOCHS <span class="token operator">=</span> <span class="token number">5</span><span class="token keyword">for</span> epoch <span class="token keyword">in</span> range<span class="token punctuation">(</span>EPOCH<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span> <span class="token keyword">in</span> train_dataset<span class="token punctuation">:</span>        train_step<span class="token punctuation">(</span>model<span class="token punctuation">,</span> optimizer<span class="token punctuation">,</span> x_train<span class="token punctuation">,</span> y_train<span class="token punctuation">)</span>    <span class="token keyword">with</span> train_summary_writer<span class="token punctuation">.</span>as_default<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        tf<span class="token punctuation">.</span>summary<span class="token punctuation">.</span>scalar<span class="token punctuation">(</span><span class="token string">'loss'</span><span class="token punctuation">,</span> train_loss<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> step<span class="token operator">=</span>epoch<span class="token punctuation">)</span>        tf<span class="token punctuation">.</span>summary<span class="token punctuation">.</span>scalar<span class="token punctuation">(</span><span class="token string">'accuracy'</span><span class="token punctuation">,</span> train_loss<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> step<span class="token operator">=</span>epoch<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>x_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span> <span class="token keyword">in</span> test_dataset<span class="token punctuation">:</span>        test_step<span class="token punctuation">(</span>model<span class="token punctuation">,</span> x_test<span class="token punctuation">,</span> y_test<span class="token punctuation">)</span>    <span class="token keyword">with</span> test_summary_writer<span class="token punctuation">.</span>as_default<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        tf<span class="token punctuation">.</span>summary<span class="token punctuation">.</span>scalar<span class="token punctuation">(</span><span class="token string">'loss'</span><span class="token punctuation">,</span> test_loss<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> step<span class="token operator">=</span>epoch<span class="token punctuation">)</span>        tf<span class="token punctuation">.</span>summary<span class="token punctuation">.</span>scalar<span class="token punctuation">(</span><span class="token string">'accuracy'</span><span class="token punctuation">,</span> test_loss<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> step<span class="token operator">=</span>epoch<span class="token punctuation">)</span>    template <span class="token operator">=</span> <span class="token string">'Epoch {}, Loss: {}, Test Loss: {}, Test Accuracy: {}'</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span>format<span class="token punctuation">(</span>epoch<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>                           train_loss<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                          train_accuracy<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">,</span>                          test_loss<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                          test_accuracy<span class="token punctuation">.</span>result<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    train_loss<span class="token punctuation">.</span>reset_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    test_loss<span class="token punctuation">.</span>reset_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    train_accuracy<span class="token punctuation">.</span>reset_state<span class="token punctuation">(</span><span class="token punctuation">)</span>    test_accuracy<span class="token punctuation">.</span>reset_state<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-Start-TensorBoard"><a href="#5-3-Start-TensorBoard" class="headerlink" title="5.3. Start TensorBoard"></a>5.3. Start TensorBoard</h3><ul><li>Notebook 中<br><code>%tensorboard --logdir logs/fit</code></li><li>终端<br><code>tensorboard --logdir=logs/fit</code></li></ul><h3 id="colab"><a href="#colab" class="headerlink" title="colab"></a>colab</h3><h4 id="unzip-file"><a href="#unzip-file" class="headerlink" title="unzip file"></a>unzip file</h4><pre class="line-numbers language-bash"><code class="language-bash"><span class="token operator">!</span>mv xxx.zip /content/%cd /content<span class="token operator">!</span>unzip xx.zip<span class="token operator">!</span>mv xxx /content/gdrive/path <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这样操作解压很快，但是同样需要将数据传输到相应的目录，也要花一点时间，或者直接读取解压后的文件目录，只是每次jupyter重启后重新<code>mv  unzip  xxx.zip</code>这样只用花费<code>mv</code>的时间，这也会极大的提高数据流的处理速度，毕竟直接在硬盘上读取数据，比在网盘上要快很多。</p><h3 id="GPU与CPU"><a href="#GPU与CPU" class="headerlink" title="GPU与CPU"></a>GPU与CPU</h3><p>要特别注意GPU与CPU的分配问题，对运算速度影响非常明显<br>可以参考<a href="https://blog.csdn.net/qq_32998593/article/details/92849585" target="_blank" rel="noopener">https://blog.csdn.net/qq_32998593/article/details/92849585</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据预处理 2</title>
      <link href="/2020/06/06/deeplearning/shu-ju-yu-chu-li-2/"/>
      <url>/2020/06/06/deeplearning/shu-ju-yu-chu-li-2/</url>
      
        <content type="html"><![CDATA[<p>这里针对具体的应用场景，来总结一些需要注意的地方。</p><blockquote><p>仅仅是随笔，并不严谨！</p></blockquote><h2 id="文本预处理中"><a href="#文本预处理中" class="headerlink" title="文本预处理中"></a>文本预处理中</h2><h3 id="设置-MAX-WORDS"><a href="#设置-MAX-WORDS" class="headerlink" title="设置 MAX_WORDS"></a>设置 <code>MAX_WORDS</code></h3><p>仅考虑最高频的一些文本信息，但这里也有很多要注意的地方。对于单个文本和整个数据集都可以做类似的考虑。<br>这样可以大大节省计算成本，提高模型的准确率。</p><ul><li>类似于PCA（主成分分析）<ul><li>起到降维的功效</li></ul></li><li>但频率最高的词并不一定具有区分度，（比如：标点符号，副词。。）<ul><li>要做的真正的PCA,还是需要一些辅助手段的，比如</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的类</title>
      <link href="/2020/06/02/python/python-zhong-de-lei/"/>
      <url>/2020/06/02/python/python-zhong-de-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="1-新式类和旧式类"><a href="#1-新式类和旧式类" class="headerlink" title="1. 新式类和旧式类"></a>1. 新式类和旧式类</h2><p>这篇文章很好的介绍了新式类的特性: <a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html" target="_blank" rel="noopener">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a></p><p>新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类继承是根据<strong>C3算法</strong>,旧式类是<strong>深度优先</strong>),&lt;Python核心编程&gt;里讲的也很多.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 一个旧式类的深度优先的例子</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">foo1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token string">"A"</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">foo2</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">foo1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token string">"C"</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>d <span class="token operator">=</span> D<span class="token punctuation">(</span><span class="token punctuation">)</span>d<span class="token punctuation">.</span>foo1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># A</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>按照经典类的查找顺序<strong>从左到右深度优先</strong>的规则，在访问<code>d.foo1()</code>的时候,<code>D</code>这个类是没有的..那么往上查找,先找到<code>B</code>,里面没有,深度优先,访问<code>A</code>,找到了<code>foo1()</code>,所以这时候调用的是<code>A</code>的<code>foo1()</code>，从而导致<code>C</code>重写的<code>foo1()</code>被绕过</p></blockquote><h2 id="2-dict-和dir-的区别"><a href="#2-dict-和dir-的区别" class="headerlink" title="2. __dict__和dir()的区别"></a>2. <code>__dict__</code>和<code>dir()</code>的区别</h2><ol><li><p>实例的<code>__dict__</code>仅存储与该实例相关的实例属性，</p><p>正是因为实例的<code>__dict__</code>属性，每个实例的实例属性才会互不影响。</p></li><li><p>类的<code>__dict__</code>存储所有实例共享的变量和函数(类属性，方法等)，类的<strong>dict</strong>并不包含其父类的属性。</p></li><li><p><code>dir()</code>是<code>Python</code>提供的一个API函数，<code>dir()</code>函数会自动寻找一个对象的所有属性(包括从父类中继承的属性)。</p></li></ol><blockquote><p>一个实例的<strong>dict</strong>属性仅仅是那个实例的实例属性的集合，并不包含该实例的所有有效属性。所以如果想获取一个对象所有有效属性，应使用dir()。</p></blockquote><h2 id="3-classmethod-和-staticmethod"><a href="#3-classmethod-和-staticmethod" class="headerlink" title="3. @classmethod 和 @staticmethod"></a>3. <code>@classmethod</code> 和 <code>@staticmethod</code></h2><blockquote><p>类的实例化过程基本遵循</p><ul><li><strong>创建实例对象</strong>、</li><li><strong>初始化实例对象</strong>、</li><li>最后<strong>返回(产生)实例对象</strong></li></ul></blockquote><p><strong>示例</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    data <span class="token operator">=</span> <span class="token string">'world'</span> <span class="token comment" spellcheck="true"># 类对象的数据成员</span>​    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>arg <span class="token operator">=</span> arg​    @staticmethod   <span class="token comment" spellcheck="true"># 静态方法，不能访问类数据成员</span>    <span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>​    @classmethod    <span class="token comment" spellcheck="true"># 类方法,能访问类数据成员</span>    <span class="token keyword">def</span> <span class="token function">getData</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>cls<span class="token punctuation">.</span>data<span class="token punctuation">)</span>​<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    t <span class="token operator">=</span> Test<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span>    Test<span class="token punctuation">.</span>func<span class="token punctuation">(</span><span class="token punctuation">)</span>    Test<span class="token punctuation">.</span>getData<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>共同</strong>:   </p><ul><li>两个都是装饰器，装饰的成员函数可以通过类名.方法名(…)来调用</li></ul><p><strong>区别</strong>:</p><ul><li>最显著的特点是<code>classmethod</code>需要传递一个参数<code>cls</code>，而<code>staticmethod</code>不需要。因此可以访问、修改类的属性，类的方法，实例化对象等，避免硬编码；而<code>staticmethod</code>不行</li><li><code>classmethod</code>可以判断出自己是通过基类被调用，还是通过某个子类被调用</li></ul><p><strong>用途</strong>：</p><p><code>classmethod</code>多用于设计模式之<strong>工厂模式</strong>,<u>将解析逻辑封装在方法本身内部</u>。<font color=blue>（也可认为构造前交互，即在进行实例化类对象之前先进行某些逻辑操作，即可看作进行不同的构造函数，然后返回一个类实例</font>，见具体代码）,更多见<code>__new__</code>和<code>__init__</code></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">time</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> year<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>time<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>year <span class="token operator">=</span> year        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>year<span class="token punctuation">)</span>​    <span class="token comment" spellcheck="true"># a class method to create a time that one day following the data 'year'</span>    @classmethod    <span class="token keyword">def</span> <span class="token function">tomorrow</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span>year<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># >>> ▲ Python所有类都继承自`&lt;class 'type'>`，包括新式类`object`</span>        <span class="token keyword">return</span> cls<span class="token punctuation">(</span>year<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>​    <span class="token comment" spellcheck="true"># a static method to check whether the given data 'year' is after 2000.</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">twoThoundYear</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> year<span class="token operator">></span><span class="token number">2000</span>​t1 <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token number">1999</span><span class="token punctuation">)</span><span class="token number">1999</span>t2 <span class="token operator">=</span> time<span class="token punctuation">.</span>tomorrow<span class="token punctuation">(</span><span class="token number">1999</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'type'</span><span class="token operator">></span><span class="token number">2000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>staticmethod</code>用法就跟其他的语言中的静态<code>static</code>用法相同（可看作是属于该类的一个工具、辅助函数）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">m1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"self:"</span><span class="token punctuation">,</span> self<span class="token punctuation">)</span>    @classmethod    <span class="token keyword">def</span> <span class="token function">m2</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"cls:"</span><span class="token punctuation">,</span> cls<span class="token punctuation">)</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">m3</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>m1<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># self: &lt;__main__.A object at 0x000001E596E41A90></span>A<span class="token punctuation">.</span>m2<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># cls: &lt;class '__main__.A'></span>A<span class="token punctuation">.</span>m3<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-实例方法"><a href="#3-1-实例方法" class="headerlink" title="3.1. 实例方法"></a>3.1. 实例方法</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>m1<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># A.m1在py2中显示为&lt;unbound method A.m1></span><span class="token operator">&lt;</span>function A<span class="token punctuation">.</span>m1 at <span class="token number">0x000002BF7FF9A488</span><span class="token operator">></span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>m1<span class="token punctuation">)</span><span class="token operator">&lt;</span>bound method A<span class="token punctuation">.</span>m1 of <span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>A object at <span class="token number">0x000002BF7FFA2BE0</span><span class="token operator">>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>A.m1</code>是一个还没有绑定实例对象的方法，对于未绑定方法，调用 <code>A.m1</code> 时必须显示地传入一个实例对象进去，而 <code>a.m1</code>是已经绑定了实例的方法，<code>python</code>隐式地把对象传递给了<code>self</code>参数，所以不再手动传递参数，这是调用实例方法的过程。</p><pre class="line-numbers language-python"><code class="language-python">A<span class="token punctuation">.</span>m1<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 等价  </span>a<span class="token punctuation">.</span>m1<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-2-类方法"><a href="#3-2-类方法" class="headerlink" title="3.2. 类方法"></a>3.2. 类方法</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>m2<span class="token punctuation">)</span><span class="token operator">&lt;</span>bound method A<span class="token punctuation">.</span>m2 of <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.A'</span><span class="token operator">>></span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>m2<span class="token punctuation">)</span><span class="token operator">&lt;</span>bound method A<span class="token punctuation">.</span>m2 of <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.A'</span><span class="token operator">>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>m2</code>是类方法，不管是<code>A.m2</code>还是 <code>a.m2</code>，都是已经自动绑定了类对象A的方法，对于后者，因为python可以通过实例对象<code>a</code>找到它所属的类是<code>A</code>，找到<code>A</code>之后自动绑定到 <code>cls</code>。</p><pre class="line-numbers language-python"><code class="language-python">A<span class="token punctuation">.</span>m2<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 等价</span>a<span class="token punctuation">.</span>m2<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这使得我们可以在实例方法中通过使用 <code>self.m2()</code>这种方式来调用类方法和静态方法。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">m1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"self:"</span><span class="token punctuation">,</span> self<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>m2<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-3-静态方法"><a href="#3-3-静态方法" class="headerlink" title="3.3. 静态方法"></a>3.3. 静态方法</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>m3<span class="token punctuation">)</span><span class="token operator">&lt;</span>function A<span class="token punctuation">.</span>m3 at <span class="token number">0x000002BF7FF9A840</span><span class="token operator">></span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>m3<span class="token punctuation">)</span><span class="token operator">&lt;</span>function A<span class="token punctuation">.</span>m3 at <span class="token number">0x000002BF7FF9A840</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>m3</code>是类里面的一个静态方法，跟普通函数没什么区别，与类和实例都没有所谓的绑定关系，它只不过是碰巧存在类中的一个函数而已。不论是通过类还是实例都可以引用该方法。</p><pre class="line-numbers language-python"><code class="language-python">A<span class="token punctuation">.</span>m3<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 等价</span>a<span class="token punctuation">.</span>m3<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-new和init的区别"><a href="#4-new和init的区别" class="headerlink" title="4. new和init的区别"></a>4. <strong>new</strong>和<strong>init</strong>的区别</h2><p><strong>知识点</strong></p><ol><li>首先要弄懂<strong>调用顺序</strong><code>__new__--&gt;__init__</code>： 所以<strong>init</strong>其实不是实例化一个类的时候第一个被调用的方法。当使用 <code>Persion(name, age)</code> 这样的表达式来实例化一个类时，最先被调用的方法 其实是<code>__new__</code>方法。<br><code>__new__</code>至少要有一个参数<code>cls</code>，代表要实例化的类，此参数在实例化时由Python解释器自动提供（实例化时加的参数，也会被认为时<code>cls</code>的属性）。即系统知道<code>__new__()</code> 方法始终都是类的类方法，即使没有被加上类方法装饰器。<br><code>__new__</code>方法接受的参数虽然也是和<code>__init__</code>一样，但<code>__init__</code>是<strong>在类实例创建之后调用</strong>，而 <code>__new__</code>方法正是创建这个类实例的方法。</li><li><code>__init__</code>有一个参数<code>self</code>，就是这个<code>__new__</code>中<code>return</code>的实例，<code>__init__</code>在<code>__new__</code>的基础上可以完成一些其它初始化的动作，<code>__init__</code>不需要返回值。而<code>__new__</code>必须有（可以<code>return</code>父类<code>__new__</code>出来的实例，或者直接是<code>object</code>的<code>__new__</code>出来的实例）。<code>__new__</code>方法决定了创建哪个类的实例（可以是父类，也可以是子类），因此不一定调用当前类的<code>__init__</code>。即（若<code>__new__</code>没有正确返回当前类<code>cls</code>的实例，那<code>__init__</code>是不会被调用的，即使是父类的实例也不行）</li><li>继承自<code>object</code>的新式类才有<code>__new__</code>，同时，在任何新式类的<code>__new__()</code>方法，不能调用自身的<code>__new__()</code>来制造实例，因为这会造成死循环，即<code>class Foo(object)</code>的<code>__new__</code>中不能<code>Foo.__new__(cls, *args, **kwargs)</code>。</li></ol><p><strong>区别</strong></p><ol><li><p><code>__init__</code> 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。</p></li><li><p><code>__new__</code> 通常用于控制生成一个新实例的过程。它是类级别的方法。</p></li></ol><p>依照Python官方文档的说法，<code>__new__</code>方法主要是当你继承一些不可变的<code>class</code>时(比如<code>int, str, tuple</code>)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的<code>metaclass</code>。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 新式类:继承自object</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>something<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'init'</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span>​    <span class="token comment" spellcheck="true"># def __new__(cls):  不行，因为A("...")参数不匹配</span>    <span class="token comment" spellcheck="true">#     pass</span>​    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'new'</span><span class="token punctuation">)</span>        self <span class="token operator">=</span> object<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># ①cls中包含了*args, **kwargs信息</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token string">'1'</span>        <span class="token keyword">return</span> self  <span class="token comment" spellcheck="true"># 调用父类的`__new__`方法会返回一个A对象，init里的参数self调用的就是这个self实例</span>        <span class="token comment" spellcheck="true"># `__new__`必须具有返回值，否则无法创建对象，因为`__init__`函数需要这个返回值</span>        <span class="token comment" spellcheck="true"># 自己在定义`__new__`的时候，参数要与`__init__`函数的参数匹配，我可以不用到这些参数，但一定要匹配。或者可以使用*arg和**args的形式。</span>​<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># a = A.__new__(A) #>>> new</span>    a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token string">'do it'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># >>> new init do it</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># {'x': '1'}</span>    <span class="token comment" spellcheck="true"># 2、new定义在type元类中，必须具有返回值，</span>    <span class="token comment" spellcheck="true"># 3、new的作用就是创建实例，然后将创建的实例传递给init进行初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong><br><code>a = A() --&gt; __new__</code>方法，<code>return</code>调用父类<code>__new__</code>生成一个类实例对象 <code>--&gt;__init__(self,...)</code>中的<code>self</code>实例就是这个父类<code>__new__</code>出来的实例</p><p><code>__new__()</code> 是在新式类中新出现的方法，它作用在构造方法建造实例之前，可以这么理解，在 Python 中存在于类里面的构造方法<code>__init__()</code> 负责将类的实例化，而在<code>__init__()</code> 启动之前，<code>__new__()</code> 决定是否要使用该 <code>__init__()</code> 方法，因为<code>__new__()</code> 可以调用其他类的构造方法或者直接返回别的对象来作为本类的实例。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 代码规范</title>
      <link href="/2019/08/21/python/python-dai-ma-gui-fan/"/>
      <url>/2019/08/21/python/python-dai-ma-gui-fan/</url>
      
        <content type="html"><![CDATA[<p>良好的书写规范有利于我们写出漂亮的代码，也方便以后查看。</p><p>参考文献:  </p><p>\1. PEP 8 – Style Guide for Python Code <a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008</a>  </p><p>\2. Google开源项目风格指南: <a href="https://zh-google-styleguide.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://zh-google-styleguide.readthedocs.io/en/latest/</a>  </p><p>\3. Python开发规范 <a href="https://www.jianshu.com/p/d414e90dc953" target="_blank" rel="noopener">https://www.jianshu.com/p/d414e90dc953</a>  </p><h2 id="函数注释样例"><a href="#函数注释样例" class="headerlink" title="函数注释样例"></a>函数注释样例</h2><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">'''    Some description of the function.    Parameters    ----------    param1: float, default=1.0        Description of the parameter    param2: {'linear', 'we'}, default='linear'        Description.    '''</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 并行处理</title>
      <link href="/2019/08/21/python/python-duo-xian-cheng/"/>
      <url>/2019/08/21/python/python-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<p>参考资料:</p><ul><li><a href="https://docs.python.org/2/library/multiprocessing.html" target="_blank" rel="noopener">multiprocessing— Process-based “threading” interface</a>  </li><li><a href="https://python.freelycode.com/contribution/detail/1364" target="_blank" rel="noopener">https://python.freelycode.com/contribution/detail/1364</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>并行处理是一种在同一台计算机的多个处理器中同时运行任务的工作模式。 这种工作模式的目的就是减少总的任务处理时间。但是进程之间的通信会有额外的开销，因此对小的任务而言，总的任务时间会有所增加而不是减少。</p><p>在Python语言中，<strong>multiprocessing</strong>模块通过使用子进程（而不是线程）来运行独立的并行进程。 它可以让您利用机器上的多个处理器（Windows和Unix），也就是说，多个进程可以完全独立的在内存中运行。</p><p>学习了本教程的内容之后，您将了解：</p><ul><li>在使用<code>multiprocessing</code>进行并行处理时，如何理解语法并组织代码?  </li><li>如何实现同步和异步并行处理？  </li><li>使用<code>multiprocessing.Pool()</code>接口完成3个不同的用例。  </li></ul><h2 id="可并行的进程数"><a href="#可并行的进程数" class="headerlink" title="可并行的进程数"></a>可并行的进程数</h2><pre class="line-numbers language-bash"><code class="language-bash">lscpu <span class="token comment" spellcheck="true"># 查看cpu详细情况</span><span class="token comment" spellcheck="true"># 获取CPU数目</span><span class="token function">import</span> multiprocessing as mpmp.cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="同步执行和异步执行"><a href="#同步执行和异步执行" class="headerlink" title="同步执行和异步执行"></a>同步执行和异步执行</h2><p>同步执行就是各个进程按照启动的先后，顺序完成。 这是通过锁定主程序直到相应的进程运行完毕来实现的。<br>而异步执行，换句话说，进程的执行不涉及锁定。这样做的结果就是，进程结果返回的顺序可能会混淆，但通常情况下，异步执行会更快完成。</p><p><strong>multiprocessing</strong> 模块中有两个对象是用来实现函数并行执行的：<strong>Pool</strong> 类和<strong>Process</strong> 类。</p><p><strong>Pool 类</strong></p><ul><li>同步执行<ul><li><code>Pool.map()</code> 和 <code>Pool.starmap()</code></li><li><code>Pool.apply()</code></li></ul></li><li>异步执行<ul><li><code>Pool.map_async()</code> 和<code>Pool.starmap_async()</code></li><li><code>Pool.apply_async()</code></li></ul></li></ul><p><strong>Process 类</strong></p><h2 id="问题讨论-计算每行中给定数值范围内的元素个数"><a href="#问题讨论-计算每行中给定数值范围内的元素个数" class="headerlink" title="问题讨论:计算每行中给定数值范围内的元素个数"></a>问题讨论:计算每行中给定数值范围内的元素个数</h2><p>第一个问题：给定一个二维矩阵（或者列表和多维列表），计算每行中给定数值范围内的元素个数。我们可以在下面的列表基础上开始工作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> time <span class="token keyword">import</span> time<span class="token comment" spellcheck="true">## prepare data</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>RandomState<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>arr <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">20000</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>data <span class="token operator">=</span> arr<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不使用并行处理的参考代码："><a href="#不使用并行处理的参考代码：" class="headerlink" title="不使用并行处理的参考代码："></a>不使用并行处理的参考代码：</h3><p>我们先看看不用并行计算它需要多长时间。为此，我们对函数<code>howmany_within_range()</code>(如下)进行重复以检查在范围内的数有多少个并返回计数</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">howmany_within_range</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> mini<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> row<span class="token punctuation">:</span>        <span class="token keyword">if</span> mini <span class="token operator">&lt;=</span> n <span class="token operator">&lt;=</span> max<span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> countresult <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> row <span class="token keyword">in</span> data<span class="token punctuation">:</span>    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>howmany_within_range<span class="token punctuation">(</span>row<span class="token punctuation">,</span> mini<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> max<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如何对函数进行并行化处理"><a href="#如何对函数进行并行化处理" class="headerlink" title="如何对函数进行并行化处理"></a>如何对函数进行并行化处理</h2><p>对代码进行并行处理通常的做法是取出其中可以多次运行的特定函数，将其放在不同的处理器上并行运行。</p><p>要做到这一点，就需要使用 <strong>Pool类</strong>对数目为n的处理器进行初始化，之后将想要并行运行的函数传递给<strong>Pool类</strong>中的并行方法。</p><p><strong>multiprocessing.Pool()</strong> 中提供了 <strong>apply()</strong>, <strong>map()</strong> 和 <strong>starmap()</strong> 等方法对传入的函数并行运行。</p><p>这简直太完美了！那么<strong>apply</strong>()和 <strong>map()</strong>之间又有什么区别呢？</p><p><code>apply()</code>和 <code>map()</code>都是把要进行并行化的函数作为主要参数。但是<strong>不同的是，</strong> <code>apply()</code>接受<code>args</code>参数， 通过args将各个参数传送给被并行化处理的函数，而<code>map</code> 仅将一个迭代器作为参数。</p><p>因此，对于简单的可迭代的操作，使用map()进行并行处理更适合，而且能更快完成工作。</p><p>当我们看到如何使用<code>apply()</code>和<code>map()</code>对函数<code>howmany_within_range()</code>进行并行化处理之后，我们还会介绍<code>starmap()</code>。</p><h3 id="Pool-apply-进行并行化处理"><a href="#Pool-apply-进行并行化处理" class="headerlink" title="Pool.apply() 进行并行化处理"></a>Pool.apply() 进行并行化处理</h3><p>我们来使用<code>multiprocessing.Pool()</code>，对<code>howmany_within_range()</code> 函数进行并行化处理。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mp<span class="token comment" spellcheck="true"># Step 1. Init multiprocessing.Pool()</span>pool <span class="token operator">=</span>mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>mp<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> <span class="token punctuation">[</span>pool<span class="token punctuation">.</span>apply<span class="token punctuation">(</span>howmany_within_range<span class="token punctuation">,</span>     args<span class="token operator">=</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> data<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Step 3. Don't forget to close</span>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Parallelizing-using-Pool-map"><a href="#Parallelizing-using-Pool-map" class="headerlink" title="Parallelizing using Pool.map()"></a>Parallelizing using Pool.map()</h3><p><code>Pool.map()</code>仅接受一个迭代器参数。 为了变通起见，我把<code>howmany_within_range</code>函数做了修改，为 <code>minimum</code> 和 <code>maximum</code>参数设定了缺省值，并另存为新的函数 <code>howmany_within_range_rowonly()</code>，这个函数可以只接受行数据列表迭代器作为输入。我知道这种做法不是<code>map()</code>的一个最好的用法，但它已经清楚地显示出它与<code>apply()</code>的不同之处。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mp<span class="token comment" spellcheck="true"># Redefine, with only 1 mandatory argument.</span><span class="token keyword">def</span> <span class="token function">howmany_within_range_rowonly</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> mini<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> max<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> row<span class="token punctuation">:</span>        <span class="token keyword">if</span> mini <span class="token operator">&lt;=</span> n <span class="token operator">&lt;=</span> max<span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> countpool <span class="token operator">=</span>mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>mp<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> pool<span class="token punctuation">.</span>map<span class="token punctuation">(</span>    howmany_within_range_rowonly<span class="token punctuation">,</span>     <span class="token punctuation">[</span>row <span class="token keyword">for</span> row <span class="token keyword">in</span> data<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Step 3. Don't forget to close</span>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用Pool-starmap-进行并行化"><a href="#使用Pool-starmap-进行并行化" class="headerlink" title="使用Pool.starmap() 进行并行化"></a>使用Pool.starmap() 进行并行化</h3><p>在前面的例子中，我们必须重新定义<code>howmany_within_range</code>函数，让其中的一对参数使用默认值。 而使用starmap()，您就能避免这样做。 你怎么问？</p><p>与<code>Pool.map</code>()一样，<code>Pool.starmap()</code>也只仅接受一个迭代器参数，但在<code>starmap()</code>中，迭代器种的每一个元件也是一个迭代器。你可以通过这个内部迭代器向被并行化处理的函数传递参数，在执行时再顺序解开，只要传递和解开的顺序一致就可以。</p><p>实际上，<code>Pool.starmap()</code>就像是一个接受参数的<code>Pool.map()</code>版本。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mppool <span class="token operator">=</span>mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>mp<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> pool<span class="token punctuation">.</span>starmap<span class="token punctuation">(</span>howmany_within_range<span class="token punctuation">,</span>     <span class="token punctuation">[</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> data<span class="token punctuation">]</span><span class="token punctuation">)</span>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异步并行处理"><a href="#异步并行处理" class="headerlink" title="异步并行处理"></a>异步并行处理</h2><p>和同步并行处理对等的异步并行处理函数 <code>apply_async()</code>，<code>map_async()</code>和<code>starmap_async()</code>允许您以异步方式并行执行进程，即下一个进程可以在前一个进程完成时立即启动，而不考虑启动顺序。 因此，无法保证结果与输入的顺序相同。</p><h3 id="使用Pool-apply-async-进行并行化"><a href="#使用Pool-apply-async-进行并行化" class="headerlink" title="使用Pool.apply_async()进行并行化"></a>使用Pool.apply_async()进行并行化</h3><p><code>apply_async()</code>的使用与<code>apply()</code>非常相似，只是你需要提供一个回调函数来告诉如何存储计算结果。</p><p>但是，使用<code>apply_async()</code>时需要注意的是，结果中的数字顺序会混乱，表明进程没有按照启动的顺序完成。</p><p>变通的办法就是，我们重新定义一个新的<code>howmany_within_range2()</code>，接受并返回迭代序号（i），然后对最终结果进行排序。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mppool <span class="token operator">=</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>mp<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Step 1: Redefine, to accept 'i', the iteration number</span><span class="token keyword">def</span> <span class="token function">howmany_within_range2</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> row<span class="token punctuation">,</span> mini<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> row<span class="token punctuation">:</span>        <span class="token keyword">if</span> mini <span class="token operator">&lt;=</span> n <span class="token operator">&lt;=</span> max<span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Step 2: Define callback function to collect the output in 'results'</span><span class="token keyword">def</span> <span class="token function">collect_results</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> results    results<span class="token punctuation">.</span>append<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Step 3: Use loop to parallelize</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> row <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>    pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>        howmany_within_range2<span class="token punctuation">,</span>        args<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> row<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        callback<span class="token operator">=</span>collect_results    <span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Step 4: Close Pool and let all the processes complete</span>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>pool<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># postpones the excution of next line of code until all processes in the queue are done</span><span class="token comment" spellcheck="true"># Step 5: Sort results [OPTIONAL]</span>results<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>results_final <span class="token operator">=</span> <span class="token punctuation">[</span>r <span class="token keyword">for</span> i<span class="token punctuation">,</span>r <span class="token keyword">in</span> results<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>apply_async()</code>时，不提供回调函数也是可以的。只是这时候，如果您不提供回调函数，那么您将获得<code>pool.ApplyResult</code>对象的列表，其中包含来自每个进程的计算输出值。 从这里，您需要使用<code>pool.ApplyResult.get()</code>方法来得到所需的最终结果。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mppool <span class="token operator">=</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>mp<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># call apply_async() without callback</span>result_objects <span class="token operator">=</span> <span class="token punctuation">[</span>pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>    howmany_within_range2<span class="token punctuation">,</span>    args <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> row<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i<span class="token punctuation">,</span>row <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># result_objects is a list of pool.ApplyResult objects</span>results <span class="token operator">=</span> <span class="token punctuation">[</span>r<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> r <span class="token keyword">in</span> result_objects<span class="token punctuation">]</span>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>pool<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用Pool-starmap-async-进行并行化"><a href="#使用Pool-starmap-async-进行并行化" class="headerlink" title="使用Pool.starmap_async()进行并行化"></a>使用Pool.starmap_async()进行并行化</h3><p>你已经见识了<code>apply_async()</code>的使用。你是否可以想象一下或者写一个 <code>starmap_async and map_async</code>的对应版本呢？  实现代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mppool <span class="token operator">=</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>mp<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>results <span class="token operator">=</span> pool<span class="token punctuation">.</span>starmap_async<span class="token punctuation">(</span>    howmany_within_range2<span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>row<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i<span class="token punctuation">,</span>row <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># with map, use 'howmany_within_range_rowonly' instead results = pool.map_async(howmany_within_range_rowonly, [row for row in data]).get()</span>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如何对Pandas-DataFrame进行并行处理？"><a href="#如何对Pandas-DataFrame进行并行处理？" class="headerlink" title="如何对Pandas DataFrame进行并行处理？"></a>如何对Pandas DataFrame进行并行处理？</h2><p>到目前为止，您已经了解了如何通过使函数在列表上工作来进行函数并行化。</p><p>但是，在处理数据分析或机器学习项目时，您可能希望对<code>Pandas Dataframe</code> 进行并行化，<code>Pandas Dataframe</code>是除了<code>numpy</code>数组之外，最常用的存储表格数据对象。</p><p>在对<code>DataFrame</code>进行并行化时，您可以把要被并行化的函数作为输入参数：</p><ul><li><code>DataFrame</code>的一行</li><li><code>DataFrame</code>的一列</li><li>整个<code>DataFrame</code></li></ul><p>前两个可以使用<code>multiprocessing</code>本身就可以完成。 但是对于最后一个，即对整个<code>dataframe</code>进行并行化，我们将使用<code>pathos</code>包，<code>pathos</code>包内部使用了<code>dill</code>进行序列化。</p><p>首先，让我们创建一个简单的<code>dataframe</code>，看看如何进行逐行和逐列进行并行化。 在用户定义的函数种使用了类似<code>pd.apply()</code>的写法，但这是并行处理。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mpdf <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span>size<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在已经有了<code>dataframe</code>。之后使用<code>hypotenuse</code>对每一行进行处理，每次同时运行4个进程。</p><p>为了做到这一点，在下面的代码中，可以看到我们使用了<code>df.itertuples(name=False)</code>。设定<code>name=False</code>， 就可以把<code>dataframe</code>中的每一行作为一个简单的元组送入<code>hypotenuse</code>函数</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hypotenuse</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> round<span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> row<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">0.5</span><span class="token keyword">with</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>    result <span class="token operator">=</span> pool<span class="token punctuation">.</span>imap<span class="token punctuation">(</span>        hypotenuse<span class="token punctuation">,</span> df<span class="token punctuation">.</span>itertuples<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span> chunked<span class="token operator">=</span><span class="token number">10</span>    <span class="token punctuation">)</span>    output <span class="token operator">=</span> <span class="token punctuation">[</span>round<span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> result<span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并行 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>武功秘籍</title>
      <link href="/2019/08/07/bubble/martial-arts-secret/"/>
      <url>/2019/08/07/bubble/martial-arts-secret/</url>
      
        <content type="html"><![CDATA[<blockquote><p>资料来源于网络，天下武功唯快不破，遂精而往。少林，少林，不秃也能变强。</p></blockquote><h2 id="第一式-ML"><a href="#第一式-ML" class="headerlink" title="第一式 ML"></a>第一式 ML</h2><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><h4 id="L1与L2区别"><a href="#L1与L2区别" class="headerlink" title="L1与L2区别"></a>L1与L2区别</h4><ol><li><ul><li>L1是模型各个参数的绝对值之和。</li><li>L2是模型各个参数的平方和的开方值。</li></ul></li><li><ul><li>L1会趋向于产生少量的特征，而其他的特征都是0.<br>因为最优的参数值很大概率出现在坐标轴上，这样就会导致某一维的权重为0 ，产生稀疏权重矩阵</li><li>L2会选择更多的特征，这些特征都会接近于0。<br>最优的参数值很小概率出现在坐标轴上，因此每一维的参数都不会是0。当最小化||w||时，就会使每一项趋近于0</li></ul></li><li><p>下降速度：最小化权值参数L1比L2变化的快</p></li><li><p>模型空间的限制：L1会产生稀疏 L2不会。</p></li></ol><h3 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><ul><li>超平面寻找最大类间隔，就是寻找最优超平面</li></ul><h4 id="svm怎么解决不容易找到超平面的问题-TODO"><a href="#svm怎么解决不容易找到超平面的问题-TODO" class="headerlink" title="svm怎么解决不容易找到超平面的问题? TODO"></a>svm怎么解决不容易找到超平面的问题? TODO</h4><p>做特征转换，核函数？</p><h2 id="第二式"><a href="#第二式" class="headerlink" title="第二式"></a>第二式</h2><h3 id="Pooling池化操作的反向梯度传播"><a href="#Pooling池化操作的反向梯度传播" class="headerlink" title="Pooling池化操作的反向梯度传播"></a>Pooling池化操作的反向梯度传播</h3><blockquote><p>参考自 <a href="https://blog.csdn.net/qq_21190081/article/details/72871704" target="_blank" rel="noopener">https://blog.csdn.net/qq_21190081/article/details/72871704</a></p></blockquote><p>核心问题是需要<strong>保证传递的loss（或者梯度）总和不变</strong>，哪来哪去</p><ul><li><strong>mean pooling</strong> 均权来，均权去</li><li><strong>max pooling</strong> 哪来哪去</li></ul><h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><h3 id="词向量"><a href="#词向量" class="headerlink" title="词向量"></a>词向量</h3><h4 id="one-hot"><a href="#one-hot" class="headerlink" title="one-hot"></a>one-hot</h4><ul><li>特点：<ul><li>每个向量互相垂直</li><li>高度稀疏</li></ul></li><li>缺点<ul><li>维度灾难：高维情形下将导致数据样本稀疏，距离计算困难，这对下游模型的负担是很重的。</li><li>有序性问题：它无法反映文本的有序性。因为语言并不是一个完全无序的随机序列。比如说，一个字之后只有接特定的字还能组成一个有意义的词，特定的一系列词按特定的顺序组合在一起才能组成一个有意义的句子。</li><li>语义鸿沟：其无法通过词向量来衡量相关词之间的距离关系，即这样的表征方法无法反映词之间的相似程度，因为任意两个向量的距离是相同的。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bubble </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>画图相关</title>
      <link href="/2019/08/07/python/matplotlib/"/>
      <url>/2019/08/07/python/matplotlib/</url>
      
        <content type="html"><![CDATA[<h2 id="图片中字体问题"><a href="#图片中字体问题" class="headerlink" title="图片中字体问题"></a>图片中字体问题</h2><pre class="line-numbers language-python"><code class="language-python">plt<span class="token punctuation">.</span>rc<span class="token punctuation">(</span><span class="token string">'text'</span><span class="token punctuation">,</span> usetex<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>rc<span class="token punctuation">(</span><span class="token string">'font'</span><span class="token punctuation">,</span> family<span class="token operator">=</span><span class="token string">'serif'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.size'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">15</span>plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'figure.constrained_layout.use'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">True</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="多线条颜色设置"><a href="#多线条颜色设置" class="headerlink" title="多线条颜色设置"></a>多线条颜色设置</h2><pre class="line-numbers language-python"><code class="language-python">colors <span class="token operator">=</span> plt<span class="token punctuation">.</span>get_cmap<span class="token punctuation">(</span><span class="token string">'brg'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="eps-不透明度"><a href="#eps-不透明度" class="headerlink" title="eps 不透明度"></a>eps 不透明度</h2><p>先保存pdf再转eps</p><pre class="line-numbers language-bash"><code class="language-bash">pdftops -eps name.pdf name.eps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python正则表达</title>
      <link href="/2019/06/03/python/python-zheng-zai-biao-da/"/>
      <url>/2019/06/03/python/python-zheng-zai-biao-da/</url>
      
        <content type="html"><![CDATA[<h2 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h2><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\cx</td><td>Control+x,x属于[A-Z a-z]</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\s</td><td>任何空白字符，包括空格、制表符、换页符等，等价于[\f\n\r\t\v]</td></tr><tr><td>\S</td><td>任何非空白字符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\r</td><td>回车符</td></tr></tbody></table><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>放到匹配字符的后边，有特殊的含义，要相匹配他们要加反斜杠转义</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>输入字符串的结尾位置，特殊的：\n \r</td></tr><tr><td>( )</td><td>标记一个子表达式的开始和结束位置</td></tr><tr><td>*</td><td>前面的子表达式零次或多次</td></tr><tr><td>+</td><td>前面的子表达式一次或多次</td></tr><tr><td>.</td><td>除换行符 \n 之外的任何单字符</td></tr><tr><td>[ ]</td><td>标记一个中括号表达式</td></tr><tr><td>?</td><td>前面的子表达式零次或一次，非贪婪的，尽可能匹配短的</td></tr><tr><td>\</td><td>转义</td></tr><tr><td>^</td><td>输入字符串的开始位，特殊的：\n \r</td></tr><tr><td>{ }</td><td>限定符表达式的开始</td></tr><tr><td></td><td>指明两项之间的一个选择</td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>指定正则表达式的一个给定组件必须要出现多少次才能满足匹配</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>前面的子表达式零次或多次</td></tr><tr><td>+</td><td>前面的子表达式一次或多次</td></tr><tr><td>?</td><td>前面的子表达式零次或一次</td></tr><tr><td>{n}</td><td>匹配确定的 n 次</td></tr><tr><td>{n,}</td><td>至少匹配n 次</td></tr><tr><td>{n,m}</td><td>最少匹配 n 次且最多匹配 m 次</td></tr></tbody></table><h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>输入字符串的开始位，特殊的：\n \r</td></tr><tr><td>$</td><td>输入字符串的结尾位置，特殊的：\n \r</td></tr><tr><td>\b</td><td>匹配一个单词边界，即字与空格间的位置</td></tr><tr><td>\B</td><td>非单词边界匹配</td></tr></tbody></table><h2 id="其他的元字符"><a href="#其他的元字符" class="headerlink" title="其他的元字符"></a>其他的元字符</h2><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>(pattern)</td><td>匹配 pattern 并获取这一匹配</td></tr><tr><td>(?:pattern)</td><td>匹配 pattern 但不获取匹配结果</td></tr><tr><td>(?=pattern)</td><td>正向肯定预查</td></tr><tr><td>(?!pattern)</td><td>正向否定预查</td></tr><tr><td>(?&lt;=pattern)</td><td>反向肯定预查，与正向肯定预查类似，只是方向相反</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反</td></tr><tr><td>x</td><td>y</td></tr><tr><td>[xyz]</td><td>字符集合，匹配所包含的任意一个字符</td></tr><tr><td>[^xyz</td><td>负值字符集合，匹配未包含的任意字符</td></tr><tr><td>[a-z]</td><td>字符范围，匹配指定范围内的任意字符</td></tr><tr><td>[^a-z]</td><td>负值字符范围，匹配任何不在指定范围内的任意字符</td></tr><tr><td>\d</td><td>匹配一个数字字符，等价于 [0-9]</td></tr><tr><td>\D</td><td>匹配一个非数字字符，等价于 [^0-9]</td></tr><tr><td>\w</td><td>匹配字母、数字、下划线,等价于 [A-Za-z0-9_]</td></tr><tr><td>\W</td><td>与\w相反，等价于 [^A-Za-z0-9_]</td></tr><tr><td>\num</td><td>匹配num个，其中 num 是一个正整数，对所获取的匹配的引用。如，’(.)\1’ 匹配两个连续的相同字符。</td></tr></tbody></table><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>优先级相同的从左到右运算</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>转义符</td></tr><tr><td>()[]</td><td>括号</td></tr><tr><td>* , +, ?, {n}, {n,}, {n,m}</td><td>限定符</td></tr><tr><td>^, $, \任何元字符、任何字符</td><td>位置和序列</td></tr><tr><td>|</td><td>或</td></tr></tbody></table><h2 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h2><ul><li>数字：<code>^[0-9]*$</code></li><li>n位的数字：<code>^\d{n}$</code></li><li>至少n位的数字：<code>^\d{n,}$</code></li><li>m-n位的数字：<code>^\d{m,n}$</code></li><li>零和非零开头的数字：<code>^(0|[1-9][0-9]*)$</code></li><li>非零开头的最多带两位小数的数字：<code>^([1-9][0-9]*)+(.[0-9]{1,2})?$</code></li><li>带1-2位小数的正数或负数：<code>^(\-)?\d+(\.\d{1,2})?$</code></li><li>正数、负数、和小数：<code>^(\-|\+)?\d+(\.\d+)?$</code></li><li>有两位小数的正实数：<code>^[0-9]+(.[0-9]{2})?$</code></li><li>有1~3位小数的正实数：<code>^[0-9]+(.[0-9]{1,3})?$</code></li><li>非零的正整数：<code>^[1-9]\d*$</code> 或 <code>^([1-9][0-9]*){1,3}$</code> 或 <code>^\+?[1-9][0-9]*$</code></li><li>非零的负整数：<code>^\-[1-9][]0-9″*$</code> 或 <code>^-[1-9]\d*$</code></li><li>非负整数：<code>^\d+$</code> 或 <code>^[1-9]\d*|0$</code></li><li>非正整数：<code>^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</code></li><li>非负浮点数：<code>^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</code></li><li><code>非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</code></li><li>正浮点数：<code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$</code> 或 <code>^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</code></li><li>负浮点数：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)</code>$ 或 <code>^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</code></li><li>浮点数：<code>^(-?\d+)(\.\d+)?$</code> 或 <code>^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></li></ul><h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><ul><li>汉字：<code>^[\u4e00-\u9fa5]{0,}$</code></li><li>英文和数字：<code>^[A-Za-z0-9]+$</code> 或 <code>^[A-Za-z0-9]{4,40}$</code></li><li>长度为3-20的所有字符：<code>^.{3,20}$</code></li><li>由26个英文字母组成的字符串：<code>^[A-Za-z]+$</code></li><li>由26个大写英文字母组成的字符串：<code>^[A-Z]+$</code></li><li>由26个小写英文字母组成的字符串：<code>^[a-z]+$</code></li><li>由数字和26个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code></li><li>由数字、26个英文字母或者下划线组成的字符串：<code>^\w+$</code> 或 <code>^\w{3,20}$</code></li><li>中文、英文、数字包括下划线：<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></li><li>中文、英文、数字但不包括下划线等符号：<code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code> 或 <code>^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</code></li><li>可以输入含有<code>^%&amp;’,;=?$\”</code>等字符：<code>[^%&amp;&#39;,;=?$\x22]+</code></li><li>禁止输入含有<del>的字符：`[^</del>\x22]+`</li></ul><h2 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h2><ul><li>Email地址：<code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></li><li>域名：<code>[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</code></li><li>InternetURL：<code>[a-zA-z]+://[^\s]*</code> 或 <code>^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></li><li>手机号码：<code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</code></li><li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：<code>^($$\d{3,4}-)|\d{3.4}-)?\d{7,8}$</code></li><li>国内电话号码(0511-4405222、021-87888822)：<code>\d{3}-\d{8}|\d{4}-\d{7}</code></li><li>身份证号(15位、18位数字)：<code>^\d{15}|\d{18}$</code></li><li>短身份证号码(数字、字母x结尾)：<code>^([0-9]){7,18}(x|X)?$</code> 或 <code>^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$</code></li><li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<code>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</code></li><li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<code>^[a-zA-Z]\w{5,17}$</code></li><li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：<code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></li><li>日期格式：<code>^\d{4}-\d{1,2}-\d{1,2}</code></li><li>一年的12个月(01～09和1～12)：<code>^(0?[1-9]|1[0-2])$</code></li><li>一个月的31天(01～09和1～31)：<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></li><li>钱的输入格式：<ul><li>有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：<code>^[1-9][0-9]*$</code></li><li>这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：<code>^(0|[1-9][0-9]*)$</code></li><li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：<code>^(0|-?[1-9][0-9]*)$</code></li><li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：<code>^[0-9]+(.[0-9]+)?$</code></li><li>必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：<code>^[0-9]+(.[0-9]{2})?$</code></li><li>这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：<code>^[0-9]+(.[0-9]{1,2})?$</code></li><li>这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：<code>^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</code></li><li>1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：<code>^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</code></li><li>备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里</li></ul></li><li>xml文件：<code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code></li><li>中文字符的正则表达式：<code>[\u4e00-\u9fa5]</code></li><li>双字节字符：<code>[^\x00-\xff]</code> (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</li><li>空白行的正则表达式：<code>\n\s*\r</code> (可以用来删除空白行)</li><li>HTML标记的正则表达式：<code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</code> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</li><li>首尾空白字符的正则表达式：<code>^\s*|\s*$或(^\s*)|(\s*$)</code> (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li><li>腾讯QQ号：<code>[1-9][0-9]{4,}</code> (腾讯QQ号从10000开始)</li><li>中国邮政编码：<code>[1-9]\d{5}(?!\d)</code> (中国邮政编码为6位数字)</li><li>IP地址：<code>\d+\.\d+\.\d+\.\d+</code> (提取IP地址时有用)</li><li>IP地址：<code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code> </li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中的单例模式</title>
      <link href="/2019/06/01/python/python-zhong-de-dan-li-mo-shi/"/>
      <url>/2019/06/01/python/python-zhong-de-dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p><p><code>__new__()</code>在<code>__init__()</code>之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例<br><strong>这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.</strong></p></blockquote><ol><li>利用<code>staticmethod</code></li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    instance <span class="token operator">=</span> None    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> SyntaxError<span class="token punctuation">(</span><span class="token string">'can not instance, please use get_instance'</span><span class="token punctuation">)</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> Singleton<span class="token punctuation">.</span>instance <span class="token keyword">is</span> None<span class="token punctuation">:</span>            Singleton<span class="token punctuation">.</span>instance <span class="token operator">=</span> object<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span>        <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>instancea <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>get_instance<span class="token punctuation">(</span><span class="token punctuation">)</span>b <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>get_instance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'a id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># a id= 4543445392</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'b id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># b id= 4543445392</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法的要点是在<code>__init__</code>抛出异常，禁止通过类来实例化，只能通过静态<code>get_instance</code>函数来获取实例；因为不能通过类来实例化，所以静态<code>get_instance</code>函数中可以通过父类<code>object.__new__</code>来实例化。</p><p>缺点： 实例化都要先调用静态方法，而且每次实例化都要调用。</p><p>若要避免每次实例化，重新调用，可以在添加一个<code>__init_flag</code>属性。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    instance <span class="token operator">=</span> None    __init_flag <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> __init_flag <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> SyntaxError<span class="token punctuation">(</span><span class="token string">'can not instance, please use get_instance'</span><span class="token punctuation">)</span>            __init_flag <span class="token operator">=</span> <span class="token boolean">False</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> Singleton<span class="token punctuation">.</span>instance <span class="token keyword">is</span> None<span class="token punctuation">:</span>            Singleton<span class="token punctuation">.</span>instance <span class="token operator">=</span> object<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span>        <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>instancea <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>get_instance<span class="token punctuation">(</span><span class="token punctuation">)</span>b <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>get_instance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'a id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># a id= 4543445392</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'b id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># b id= 4543445392</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><code>classmethod</code></li></ol><p>和方法一类似，代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    instance <span class="token operator">=</span> None    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> SyntaxError<span class="token punctuation">(</span><span class="token string">'can not instance, please use get_instance'</span><span class="token punctuation">)</span>     @classmethod    <span class="token keyword">def</span> <span class="token function">get_instance</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> Singleton<span class="token punctuation">.</span>instance <span class="token keyword">is</span> None<span class="token punctuation">:</span>            Singleton<span class="token punctuation">.</span>instance <span class="token operator">=</span> object<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 这样不可以实例化 c = Singleton 会报错，可以修改这一行和注释掉__init__中的raise SytaxError</span>        <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>instance <span class="token comment" spellcheck="true"># 若要添加属性，返回Singleton或者cls即可，属性就会被添加进去</span>a <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>get_instance<span class="token punctuation">(</span><span class="token punctuation">)</span>b <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>get_instance<span class="token punctuation">(</span><span class="token punctuation">)</span>c <span class="token operator">=</span> Singleton<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'a id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># a id= 4558530128</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'b id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># b id= 4558530128</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'b id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># c id= 4558530704</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法的要点是在<code>__init__</code>抛出异常，禁止通过类来实例化，只能通过静态<code>get_instance</code>函数来获取实例；因为不能通过类来实例化，所以静态<code>get_instance</code>函数中可以通过父类<code>object.__new__</code>来实例化。</p><p>缺点同上，且只能在<code>get_instance</code>方法中实现，实例化<code>c = Singleton()</code>与<code>a = Singleton.get_instance()</code>的<code>id</code>不同</p><ol start="3"><li>使用<code>__new__</code>方法</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token string">'_instance'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            orig <span class="token operator">=</span> super<span class="token punctuation">(</span>Singleton<span class="token punctuation">,</span> cls<span class="token punctuation">)</span>            cls<span class="token punctuation">.</span>_instance <span class="token operator">=</span> orig<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>_instance<span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>共享属性<br>创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Borg</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    _state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>        ob <span class="token operator">=</span> super<span class="token punctuation">(</span>Borg<span class="token punctuation">,</span> cls<span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>        ob<span class="token punctuation">.</span>__dict__ <span class="token operator">=</span> cls<span class="token punctuation">.</span>_state        <span class="token keyword">return</span> ob<span class="token keyword">class</span> <span class="token class-name">MyClass2</span><span class="token punctuation">(</span>Borg<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>装饰器版本</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">singleton</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>    instances <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">def</span> <span class="token function">getinstance</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> cls <span class="token operator">not</span> <span class="token keyword">in</span> instances<span class="token punctuation">:</span>            instances<span class="token punctuation">[</span>cls<span class="token punctuation">]</span> <span class="token operator">=</span> cls<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>        <span class="token keyword">return</span> instances<span class="token punctuation">[</span>cls<span class="token punctuation">]</span>    <span class="token keyword">return</span> getinstance@singleton<span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li><code>import</code>方法<br>作为python的模块是天然的单例模式</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 5. mysingleton.py</span><span class="token keyword">class</span> <span class="token class-name">My_Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>my_singleton <span class="token operator">=</span> My_Singleton<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 6. to use</span><span class="token keyword">from</span> mysingleton <span class="token keyword">import</span> my_singletonmy_singleton<span class="token punctuation">.</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>

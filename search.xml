<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>vscode 远程开发</title>
      <link href="/2020/06/09/vs-code/vscode-yuan-cheng-kai-fa-pei-zhi/"/>
      <url>/2020/06/09/vs-code/vscode-yuan-cheng-kai-fa-pei-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="VScode-远程开发配置"><a href="#VScode-远程开发配置" class="headerlink" title="VScode 远程开发配置"></a>VScode 远程开发配置</h1><p>赶在疫情期间，一切似乎都不是那么顺利，不能回到办公室，只能隔离在家，拿着可怜的奋战了多年的14款MBA，实在捉襟见肘。感谢VScode的开发团队，让我的MBA可以再奋战几年，目前正在攒机，弄个高配的台式，一劳永逸。</p><p>参考链接：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/89662757" target="_blank" rel="noopener">知乎韩冰-使用VScode进行远程炼丹</a></li><li><a href="https://zhuanlan.zhihu.com/p/141205262" target="_blank" rel="noopener">「效率」使用VScode连接远程服务器进行开发</a></li></ul><p>感谢两位分享。</p><h3 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h3><p>利用云服务器作为跳板，使得外网<strong>低配</strong>电脑，可以访问内网<strong>高配台式机</strong>。</p><h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><ul><li>VS Code</li><li>云服务器</li></ul><h2 id="购买云服务器"><a href="#购买云服务器" class="headerlink" title="购买云服务器"></a>购买云服务器</h2><p>腾讯云或者阿里云都可以，我这里用的腾讯云，最便宜的1核2线程，10元/月。选择Ubuntu系统。</p><blockquote><p>这里最好重新设置一下用户名和密码，并做一定的保护措施。</p></blockquote><h3 id="安装-VS-Code"><a href="#安装-VS-Code" class="headerlink" title="安装 VS Code"></a>安装 VS Code</h3><p>本地安装 VS code ，安装Remote Development全家桶插件。</p><p>配置<code>~/.ssh/congfig</code></p><pre><code>Host 昵称（起个名字）HostName 服务器ip （例如：127.0.10.8）User 用户名Port 22 （默认为22）</code></pre><p>这样一般就使用VS code访问服务器了。</p><h3 id="设置免密登入"><a href="#设置免密登入" class="headerlink" title="设置免密登入"></a>设置免密登入</h3><p>上述配置后，每次登入还要输入密码，这里可以设置一下ssh免密登入。</p><blockquote><p>设置之后,可以吧密码登入给取消掉，这样更安全。</p></blockquote><ul><li><strong>在本地PC生成ssh公钥和私钥</strong></li></ul><pre><code>ssh-keygen -t rsa</code></pre><p>设置过程中一般直接确认就好，默认设置。</p><ul><li><strong>手动上传公钥文件</strong><br>将本地的公钥文件上传到服务器上，然后在服务器需要免密登录的用户家目录下查看是否有 <code>~/.ssh/authorized_keys</code> 这个文件，<br>如果没有手动创建一个:</li></ul><pre class="line-numbers language-text"><code class="language-text">touch ~/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>然后我们将公钥内容写入到authorized_keys文件中，因为这个文件可能已经有内容了，所以你可以使用如下方式</li></ul><pre class="line-numbers language-text"><code class="language-text">cat -n ~/.ssh/rsa.pub ~/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>将.ssh目录的权限为700</li><li>将authorized_keys目录的权限为600</li></ol><pre class="line-numbers language-text"><code class="language-text">chmod 700 ~/.ssh/chmode 600 ~/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>自动上传本地公钥</strong><br>ssh-copy-id 复制公钥<br>这个工具还蛮有用的，不过它会将我本地的所有公钥都传到服务器，使用方法：</li></ul><pre class="line-numbers language-text"><code class="language-text">ssh-copy-id -p 22 username@remote-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="使用autossh进行内网穿透"><a href="#使用autossh进行内网穿透" class="headerlink" title="使用autossh进行内网穿透"></a>使用autossh进行内网穿透</h3><p>设想这样的场景，你在公司或者学校有一台用于炼丹的服务器，但是只能在内网访问。我在家里使用笔记本也想连接到远程的服务器中，这时我们应该怎么办呢。</p><p>答案是我们需要一台具有公网ip的服务器作为中继，使用autossh将公网服务器作为代理服务器。假设公网服务器为主机A，内网炼丹炉为主机B，我们的笔记本为C则</p><h4 id="主机B上的操作"><a href="#主机B上的操作" class="headerlink" title="主机B上的操作"></a>主机B上的操作</h4><p>将主机B上的公钥拷贝到公网主机C实现B对C的免密登录（具体参考《ssh设置免密登录》），在主机B上执行autossh命令（可以在screen环境下执行）</p><pre class="line-numbers language-console"><code class="language-console">screen -S reverse_proxyautossh -M 5555 -NR 9999:127.0.0.1:9988 -p 22 username@remote-server<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>-M是公网主机echo的地址，9999是公网服务器的转发端口，第一个22是B主机ssh端口，-p 后面是外网主机ssh端口，最后一个参数是公网主机远程登录地址。使用该命令时保证公网主机5555， 9999端口都是空闲状态。（这两个端口可以改成任意空闲端口）</p><h4 id="主机A上操作"><a href="#主机A上操作" class="headerlink" title="主机A上操作"></a>主机A上操作</h4><p>主机A此时可以直接通过ssh访问公网主机的9999端口访问到B主机的终端，具体操作为</p><pre class="line-numbers language-console"><code class="language-console">ssh -p 9999 username@remote-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证登录成功后，我们在vscode中配置A服务器的ip，和转发端口后就可以连接我们的内网主机了。</p><h3 id="配置-ssh-config"><a href="#配置-ssh-config" class="headerlink" title="配置.ssh/config"></a>配置.ssh/config</h3><pre><code>Host Fish.Tencent    HostName 175.1.0.9    User ubuntu    Port 22Host Fish.Tencent.office    HostName 127.0.0.1    User xxsx    ProxyCommand ssh -W %h:%p -q Fish.Tencent    Port 9988</code></pre><blockquote><p>这一步平不清楚</p><ul><li><strong>这里没有解决jupyter notebook远程服务器连接问题，但是通过内网可以直接访问，说明上面的设置不对</strong></li><li><a href="https://zhuanlan.zhihu.com/p/74193910" target="_blank" rel="noopener">SSH 通过跳板机直接访问内网机器</a>可能可以解决这个问题</li></ul></blockquote><p>最后莫忘了给台式机配个机械硬盘，做每日备份。</p>]]></content>
      
      
      <categories>
          
          <category> VS Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据预处理</title>
      <link href="/2020/06/06/tensorflow/shu-ju-yu-chu-li/"/>
      <url>/2020/06/06/tensorflow/shu-ju-yu-chu-li/</url>
      
        <content type="html"><![CDATA[<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><p>数据的质量至关重要，可能直接决定了模型的预测和泛化能力。它涉及很多因素，包括：准确性、完整性、一致性、时效性、可信性和解释性。</p><p>而现实中我们拿到的数据可能包含了大量的缺失值，可能包含大量的噪音，也可能因为人工录入错误导致有异常存在。</p><p>因此，拿到数据后要对数据进行清洗处理，得到标准的、干净的。连续的数据，供给数据统计或者数据挖掘使用</p><blockquote><p><strong>参考：</strong></p><ul><li><a href="https://zhuanlan.zhihu.com/p/51131210" target="_blank" rel="noopener">整理一份详细的数据预处理方法</a></li><li><a href="https://zhuanlan.zhihu.com/p/87792056" target="_blank" rel="noopener">最全面的数据预处理介绍</a></li></ul></blockquote><h2 id="1-数据可能存在的问题"><a href="#1-数据可能存在的问题" class="headerlink" title="1. 数据可能存在的问题"></a>1. 数据可能存在的问题</h2><ul><li><p><strong>数据缺失</strong> （Incomplete） 是属性值为空的情况。如 Occupancy = “ ”</p></li><li><p><strong>数据噪声</strong> （Noisy）是数据值不合常理的情况。如 Salary = “-100”</p></li><li><p><strong>数据不一致</strong> （Inconsistent）是数据前后存在矛盾的情况。如 Age = “42” vs. Birthday = “01/09/1985”</p></li><li><p><strong>数据冗余</strong> （Redundant）是数据量或者属性数目超出数据分析需要的情况。</p></li><li><p><strong>数据集不均衡</strong> （Imbalance）是各个类别的数据量相差悬殊的情况。</p></li><li><p><strong>离群点/异常值</strong> （Outliers）是远离数据集中其余部分的数据。</p></li><li><p><strong>数据重复</strong>（Duplicate）是在数据集中出现多次的数据。</p></li></ul><h2 id="2-数据预处理步骤"><a href="#2-数据预处理步骤" class="headerlink" title="2. 数据预处理步骤"></a>2. 数据预处理步骤</h2><p>数据进行预处理主要有以下步骤，第一部分提及的各种脏数据的处理就在这些步骤中完成：</p><ul><li><p><strong>数据清洗</strong> Data Cleansing</p><ul><li><strong>数据集成</strong></li><li><strong>数据规约</strong></li></ul></li><li><p><strong>数据转换</strong> Data Transformation</p><ul><li>采样</li><li>类型转换</li><li>归一化、离散化、稀疏化</li></ul></li><li><p><strong>数据描述</strong> Data Description</p></li><li><p><strong>特征选择</strong> Feature Selection 或特征组合 Feature Combination</p></li><li><p><strong>特征抽取</strong> Feature Extraction</p></li></ul><h3 id="2-1-数据清洗"><a href="#2-1-数据清洗" class="headerlink" title="2.1 数据清洗"></a>2.1 数据清洗</h3><p>这里主要处理第一部分提及的缺失数据、离散点和重复数据</p><h5 id="2-1-1-1-缺失值得处理"><a href="#2-1-1-1-缺失值得处理" class="headerlink" title="2.1.1.1 缺失值得处理"></a>2.1.1.1 缺失值得处理</h5><p><strong>缺失数据有以下几类：</strong></p><p>a.Missing completely at random: <strong>缺失的概率是随机的</strong>，比如门店的计数器因为断电断网等原因在某个时段数据为空。</p><p>b.Missing conditionally at random: <strong>数据是否缺失取决于另外一个属性</strong>，比如一些女生不愿意填写自己的体重。</p><p>c.Not missing at random: <strong>数据缺失与自身的值有关</strong>，比如高收入的人可能不愿意填写收入。</p><p><strong>处理方式有以下几种：</strong></p><ul><li><p><strong>删除变量</strong>：若变量的缺失率较高（大于80%），覆盖率较低，且重要性较低，可以直接将变量删除。</p></li><li><p>定制填充： 工程中常见用-9999进行替代</p></li><li><p><strong>统计量填充</strong>：若缺失率较低（小于95%）且重要性较低，则根据数据分布的情况进行填充。对于数据符合均匀分布，用该变量的均值填补缺失，对于数据存在倾斜分布的情况，采用中位数进行填补。</p></li><li><p>插值法填充：包括随机插值，多重差补法，热平台插补，拉格朗日插值，牛顿插值等</p></li><li><p>模型填充：使用回归、贝叶斯、随机森林、决策树等模型对缺失数据进行预测。</p></li><li><p><strong>哑变量填充</strong>：若变量是离散型，且不同值较少，可转换成哑变量，例如性别SEX变量，存在male,fameal,NA三个不同的值，可将该列转换成 IS_SEX_MALE, IS_SEX_FEMALE, IS_SEX_NA。<em>若某个变量存在十几个不同的值，可根据每个值的频数，将频数较小的值归为一类’other’，降低维度。</em>此做法可最大化保留变量的信息。</p></li></ul><p>总结来看，常用的做法是：先用<code>pandas.isnull.sum()</code>检测出变量的缺失比例，考虑删除或者填充，若需要填充的变量是连续型，一般采用均值法和随机差值进行填充，若变量是离散型，通常采用中位数或哑变量进行填充。</p><p><strong>注意：</strong>若对变量进行分箱离散化，一般会将缺失值单独作为一个箱子（离散变量的一个值）</p><h5 id="2-1-1-2-离群点处理"><a href="#2-1-1-2-离群点处理" class="headerlink" title="2.1.1.2 离群点处理"></a>2.1.1.2 离群点处理</h5><p>异常值是数据分布的常态，处于特定分布区域或范围之外的数据通常被定义为异常或噪声。异常分为两种：“伪异常”，由于特定的业务运营动作产生，是正常反应业务的状态，而不是数据本身的异常；“真异常”，不是由于特定的业务运营动作产生，而是数据本身分布异常，即离群点。主要有以下检测离群点的方法：</p><ul><li><strong>简单统计分析</strong>：根据箱线图、各分位点判断是否存在异常，例如pandas的describe函数可以快速发现异常值。</li><li>$3 \sigma$  原则：若数据存在正态分布，偏离均值的之$3 \sigma$外. 通常定义 $P(|x-\mu|&gt;3\sigma)\le0.003$ 范围内的点为离群点。</li><li><strong>基于绝对离差中位数（MAD）</strong>：这是一种稳健对抗离群数据的距离值方法，采用计算各观测值与平均值的距离总和的方法。放大了离群值的影响。</li><li>基于距离：通过定义对象之间的临近性度量，根据距离判断异常对象是否远离其他对象，缺点是计算复杂度较高，不适用于大数据集和存在不同密度区域的数据集</li><li>基于密度：离群点的局部密度显著低于大部分近邻点，适用于非均匀的数据集</li><li>基于聚类：利用聚类算法，丢弃远离其他簇的小簇。</li><li>在sklearn(一个python机器学习包)中提供了多种方法，如OneClassSVM、Isolation Forest、Local Outlier Factor (LOF)。</li></ul><p>总结来看，在数据处理阶段将离群点作为影响数据质量的异常点考虑，而不是作为通常所说的异常检测目标点，因而楼主一般采用较为简单直观的方法，结合箱线图和MAD的统计方法判断变量的离群点。</p><p>具体的处理手段：</p><ul><li>根据异常点的数量和影响，考虑是否将该条记录删除，信息损失多</li><li>若对数据做了log-scale 对数变换后消除了异常值，则此方法生效，且不损失信息</li><li>平均值或中位数替代异常点，简单高效，信息的损失较少</li><li>在训练树模型时，树模型对离群点的鲁棒性较高，无信息损失，不影响模型训练效果</li></ul><h5 id="2-1-1-3-噪声处理"><a href="#2-1-1-3-噪声处理" class="headerlink" title="2.1.1.3 噪声处理"></a>2.1.1.3 噪声处理</h5><p>噪声是变量的随机误差和方差，是观测点和真实点之间的误差，即 $obs = x+\varepsilon$ 。通常的处理办法：对数据进行分箱操作，等频或等宽分箱，然后用每个箱的平均数，中位数或者边界值（不同数据分布，处理方法不同）代替箱中所有的数，起到平滑数据的作用。另外一种做法是，建立该变量和预测变量的回归模型，根据回归系数和预测变量，反解出自变量的近似值。</p><h5 id="2-1-1-4-重复数据的处理"><a href="#2-1-1-4-重复数据的处理" class="headerlink" title="2.1.1.4 重复数据的处理"></a>2.1.1.4 重复数据的处理</h5><p>如果高度疑似的样本是挨着的，就可以用滑动窗口对比，为了让相似记录相邻，可以每条记录生成一个hash key, 根据key去排序。</p><h4 id="2-1-2-数据集成"><a href="#2-1-2-数据集成" class="headerlink" title="2.1.2 数据集成"></a>2.1.2 数据集成</h4><p>数据分析任务多半涉及数据集成。数据集成将多个数据源中的数据结合成、存放在一个一致的数据存储，如数据仓库中。这些源可能包括多个数据库、数据方或一般文件。</p><ol><li>实体识别问题：例如，数据分析者或计算机如何才能确信一个数 据库中的 <em>customer_id</em> 和另一个数据库中的 <em>cust_number</em> 指的是同一实体?通常，数据库和数据仓库 有元数据——关于数据的数据。这种元数据可以帮助避免模式集成中的错误。</li><li>冗余问题。一个属性是冗余的，如果它能由另一个表“导出”;如年薪。属性或 维命名的不一致也可能导致数据集中的冗余。 用相关性检测冗余：数值型变量可计算相关系数矩阵，标称型变量可计算卡方检验。</li><li>数据值的冲突和处理：不同数据源，在统一合并时，保持规范化，去重。</li></ol><h4 id="2-1-3-数据规约"><a href="#2-1-3-数据规约" class="headerlink" title="2.1.3 数据规约"></a>2.1.3 数据规约</h4><p>数据归约技术可以用来得到数据集的归约表示，它小得多，但仍接近地保持原数据的完整性。 这样，在归约后的数据集上挖掘将更有效，并产生相同(或几乎相同)的分析结果。一般有如下策略：</p><p>1、维度规约</p><p>用于数据分析的数据可能包含数以百计的属性，其中大部分属性与挖掘任务不相关，是冗余的。维度归约通过删除不相关的属性，来减少数据量，并保证信息的损失最小。</p><p><strong>属性子集选择：</strong>目标是找出最小属性集，使得数据类的概率分布尽可能地接近使用所有属性的原分布。在压缩的属性集上挖掘还有其它的优点。它减少了出现在发现模式上的属性的数目，使得模式更易于理解。</p><ul><li>逐步向前选择：该过程由空属性集开始，选择原属性集中最好的属性，并将它添加到该集合中。在其后的每一次迭代，将原属性集剩下的属性中的最好的属性添加到该集合中。</li><li>逐步向后删除：该过程由整个属性集开始。在每一步，删除掉尚在属性集中的最坏属性。</li><li>向前选择和向后删除的结合：向前选择和向后删除方法可以结合在一起，每一步选择一个最 好的属性，并在剩余属性中删除一个最坏的属性。</li></ul><p><code>python scikit-learn</code> 中的递归特征消除算法<code>Recursive feature elimination (RFE)</code>，就是利用这样的思想进行特征子集筛选的，一般考虑建立SVM或回归模型。</p><p><strong>单变量重要性：</strong>分析单变量和目标变量的相关性，删除预测能力较低的变量。这种方法不同于属性子集选择，通常从统计学和信息的角度去分析。</p><ul><li>pearson相关系数和卡方检验，分析目标变量和单变量的相关性。</li><li>回归系数：训练线性回归或逻辑回归，提取每个变量的表决系数，进行重要性排序。</li><li>树模型的Gini指数：训练决策树模型，提取每个变量的重要度，即Gini指数进行排序。</li><li>Lasso正则化：训练回归模型时，加入L1正则化参数，将特征向量稀疏化。</li><li>IV指标：风控模型中，通常求解每个变量的IV值，来定义变量的重要度，一般将阀值设定在0.02以上。</li></ul><p>以上提到的方法，没有讲解具体的理论知识和实现方法，需要自己去熟悉掌握。通常的做法是根据业务需求来定，如果基于业务的用户或商品特征，需要较多的解释性，考虑采用统计上的一些方法，如变量的分布曲线，直方图等，再计算相关性指标，最后去考虑一些模型方法。如果建模需要，则通常采用模型方法去筛选特征，如果用一些更为复杂的GBDT，DNN等模型，建议不做特征选择，而做特征交叉。</p><p>2、维度变换：</p><p>维度变换是将现有数据降低到更小的维度，尽量保证数据信息的完整性。楼主将介绍常用的几种有损失的维度变换方法，将大大地提高实践中建模的效率</p><ul><li>主成分分析（PCA）和因子分析（FA）：PCA通过空间映射的方式，将当前维度映射到更低的维度，使得每个变量在新空间的方差最大。FA则是找到当前特征向量的公因子（维度更小），用公因子的线性组合来描述当前的特征向量。</li><li>奇异值分解（SVD）：SVD的降维可解释性较低，且计算量比PCA大，一般用在稀疏矩阵上降维，例如图片压缩，推荐系统。</li><li>聚类：将某一类具有相似性的特征聚到单个变量，从而大大降低维度。</li><li>线性组合：将多个变量做线性回归，根据每个变量的表决系数，赋予变量权重，可将该类变量根据权重组合成一个变量。</li><li>流行学习：流行学习中一些复杂的非线性方法，可参考skearn：<a href="https://scikit-learn.org/stable/auto_examples/manifold/plot_lle_digits.html" target="_blank" rel="noopener">LLE Example</a></li></ul><h3 id="2-2-数据转换"><a href="#2-2-数据转换" class="headerlink" title="2.2 数据转换"></a>2.2 数据转换</h3><p><strong>在数据转换阶段，我们对数据进行采样处理、类型转换、归一化、离散化、稀疏化处理。</strong></p><h4 id="2-2-1-采样"><a href="#2-2-1-采样" class="headerlink" title="2.2.1 采样"></a>2.2.1 采样</h4><p><strong>采样</strong>是从特定的概率分布中抽取样本点的过程。采样在机器学习中有非常重要的应用：将复杂分布简化为离散的样本点；用重采样可以对样本集进行调整以更好地进行调整并适应后期的模型学习；用于随机模拟以进行复杂模型的近似求解或推理。采样的一个重要作用是处理不均衡数据集。</p><p>最简单的处理不均衡样本集的方法是随机采样。采样一般分为过采样（Over-sampling）和欠采样（Under-sampling）。随机过采样是从少数类样本集 S_min中有放回地随机重复抽取样本，随机欠采样是从多数类样本集S_max中随机选取较少样本。两种方法也存在问题，如随机过采样会扩大数据规模，容易造成过拟合；随机欠采样可能损失部分有用信息，造成欠拟合。为了解决上诉问题，通常在随机过采样时不是简单复制样本，而是采取一定方法生成新的样本。如使用SMOTE（Synthetic Minority Oversampling Technique）算法、Borderline-SMOTE、ADASYN等算法。对于欠采样，可以采用Informed Undersampling来解决数据丢失问题。</p><p>PS：当总体数据量不够时，除了简化模型，我们可以借鉴随机过采样的方法，对每个类进行过采样。具体到图像任务，还可以直接在图像空间进行变换，如可以通过对图像施加一定幅度的变换（旋转、平移、缩放、裁剪、填充、翻转、添加噪声、颜色变换、改变亮度、清晰度、对比度等），得到扩充的数据集。此外，迁移学习也是在小数据集上进行建模的好方法。</p><p>PS：整体准确率不适用于不平衡数据集，需要引入新的度量模式比如<strong>G-mean</strong>, 它会看正类上的准确率，再看负类上的准确率，然后两者相乘取平方根。另外一种常见的度量如<strong>F-score</strong>。</p><h4 id="2-2-2-类型转换"><a href="#2-2-2-类型转换" class="headerlink" title="2.2.2 类型转换"></a>2.2.2 类型转换</h4><p>在<strong>类型转换</strong>处理前，我们先来看下数据的类型。</p><p>数据类型可以简单划分为数值型和非数值型。数值型有连续型和离散型。非数值型有类别型和非类别型，其中类别型特征中如果类别存在排序问题为定序型，若不存在排序问题则为定类型，非类别型是字符串型。如下所示：</p><ul><li><p><strong>连续型 Continuous</strong>  Real values: Temperature, Height, Weight …</p></li><li><p><strong>离散型 Discrete</strong>  Integer values: Number of people …</p></li><li><p><strong>定序型 Ordinal</strong>  Rankings: {Average, Good, Best}, {Low, Medium, High} …</p><p>对于定序型，我们可以使用<strong>序号编码</strong>，如成绩，分为Average, Good, Best三档，序号编码可以按照大小关系对定序型特征赋予一个数值ID，例如Average表示为1，Good表示为2，Best表示为3，转换后依旧保留了大小关系。</p></li><li><p><strong>定类型 Nominal</strong>  Symbols: {Teacher, Worker, Salesman}, {Red, Green, Blue} …</p><p>对于定类型，我们可以使用<strong>独热编码</strong>，如颜色三原色，为Red, Green, Blue，独热编码可以把三原色变为一个三维稀疏向量，Red表示为（0，0，1），Green表示为（0，1，0），Blue表示为（1，0，0）。需要注意的是，在类别值较多的情况下，可以使用稀疏向量来节省空间，目前大部分算法实现均接受稀疏向量形式的输入。当然还有很多别的编码方式，如二进制编码等，感兴趣的可以额外查阅资料了解。</p></li><li><p><strong>字符串型 String</strong>  Text: “Tsinghua University”, “No. 123, Pingan Avenue” …</p><p>对于字符串型，我们有多种表示方式，如<strong>词袋模型（Bag of Words）</strong>，<strong>TF-IDF（Term Frequency-Inverse）</strong>，<strong>主题模型（Topic Model）</strong>，<strong>词嵌入模型（Word Embedding）</strong>。各种表示有不同的适用场景和优缺点，需要进一步了解的可以额外查资料。</p></li><li><p>对于非数值型，我们需要进行类别转换，即将非数值型转换为数值型，以方便机器学习算法后续处理。</p></li></ul><h4 id="2-2-3-归一化处理"><a href="#2-2-3-归一化处理" class="headerlink" title="2.2.3 归一化处理"></a>2.2.3 归一化处理</h4><p>经过类别转换后，我们所有的数据均转为了数值型。为了消除数据特征之间的量纲影响，我们需要对特征进行<strong>归一化</strong>处理，使不同指标之间具有可比性。</p><p><strong>规范化处理：</strong>数据中不同特征的量纲可能不一致，数值间的差别可能很大，不进行处理可能会影响到数据分析的结果，因此，需要对数据按照一定比例进行缩放，使之落在一个特定的区域，便于进行综合分析。特别是基于距离的挖掘方法，聚类，KNN，SVM一定要做规范化处理。</p><ul><li>最大 - 最小规范化：将数据映射到[0,1]区间， $x_{new}=\frac{x-x_{min}}{x_{max}-x_{min}}$</li></ul><ul><li>Z-Score标准化：处理后的数据均值为0，方差为1， $x_{new}=\frac{x-\overline{x}}{\sigma}$</li></ul><ul><li>Log变换：在时间序列数据中，对于数据量级相差较大的变量，通常做Log函数的变换， $x_{new}=\log x$ .</li></ul><p><strong>离散化处理：</strong>数据离散化是指将连续的数据进行分段，使其变为一段段离散化的区间。分段的原则有基于等距离、等频率或优化的方法。数据离散化的原因主要有以下几点：</p><ul><li>模型需要：比如决策树、朴素贝叶斯等算法，都是基于离散型的数据展开的。如果要使用该类算法，必须将离散型的数据进行。有效的离散化能减小算法的时间和空间开销，提高系统对样本的分类聚类能力和抗噪声能力。</li><li>离散化的特征相对于连续型特征更易理解。</li><li>可以有效的克服数据中隐藏的缺陷，使模型结果更加稳定。</li></ul><p>等频法：使得每个箱中的样本数量相等，例如总样本n=100，分成k=5个箱，则分箱原则是保证落入每个箱的样本量=20。</p><p>等宽法：使得属性的箱宽度相等，例如年龄变量（0-100之间），可分成 [0,20]，[20,40]，[40,60]，[60,80]，[80,100]五个等宽的箱。</p><p>聚类法：根据聚类出来的簇，每个簇中的数据为一个箱，簇的数量模型给定。</p><p><strong>稀疏化处理：</strong>针对离散型且标称变量，无法进行有序的LabelEncoder时，通常考虑将变量做0，1哑变量的稀疏化处理，例如动物类型变量中含有猫，狗，猪，羊四个不同值，将该变量转换成<code>is_猪，is_猫，is_狗，is_羊</code>四个哑变量。若是变量的不同值较多，则根据频数，将出现次数较少的值统一归为一类’rare’。稀疏化处理既有利于模型快速收敛，又能提升模型的抗噪能力。</p><h3 id="2-3-数据描述"><a href="#2-3-数据描述" class="headerlink" title="2.3 数据描述"></a>2.3 数据描述</h3><p><strong>在数据描述阶段，我们可以根据需要计算统计量和对数据进行可视化。</strong></p><p>数据的一般性描述有<strong>mean</strong>, <strong>median</strong>, <strong>mode</strong>, <strong>variance</strong>.</p><p>mean是均值；median是中位数，取数据排序后在中间位置的值，避免因为极端离群点影响客观评价；mode是出现频率最高的元素，其实用的比较少；variance是方差衡量数据集与其均值的偏离。</p><p>数据之间的相关性可以使用<strong>Pearson correlation coefficient和Pearson chi-square</strong>进行度量。前者适用与有metric data的情况，后者适用于分类统计的情况。</p><p><strong>数据可视化</strong>一维数据圆饼图，柱状图；二维数据散点图；三维数据用三维坐标呈现；高维数据需要先做转换或映射，比如用matlab的Box Plots，也可以用平行坐标呈现。可使用工具有很多，如matlab和Geph。</p><h3 id="2-4-特征选择"><a href="#2-4-特征选择" class="headerlink" title="2.4 特征选择"></a>2.4 特征选择</h3><p>参见[数据规约]</p><p>当我们做特定分析的时候，可能属性非常多，但有些属性是不相关的，有些属性是重复的，所以我们需要用<strong>特征选择</strong>挑选出来最相关的属性降低问题难度。</p><p>我们可以通过熵增益(Entropy Information Gain)、分支定界（Branch and Bound）等方式进行特征选择。特征选择还有sequential forward, sequential backward, simulated annealing(模拟退火), tabu search(竞技搜索), genetic algorithms(遗传算法)等方式去优化。</p><p>为了提高复杂关系的拟合能力，在特征工程中经常会把一些离散特征两两<strong>组合</strong>，构成高阶特征。如在点击率预测问题中，原始数据有语言和类型两种特征，为了提高拟合能力，语言和类型可以组合成二阶特征，联合预测对点击率的影响。如何找到有意义的组合特征？有一种方法是基于决策树的组合特征寻找方法。</p><p>在机器学习中，数据通常需要表示为向量的形式进行训练，但是在对高维向量进行处理和分析时，会极大消耗系统资源，甚至产生维度灾难。因此，使用低维度的向量来表示高维度的向量就十分必要。<strong>特征抽取或降维</strong>即使用低纬度向量表示高维度向量的方法。</p><p><strong>特征抽取是</strong>主要有主成分分析（Principal Component Analysis，PCA）和线性判别分析（Linear Discriminant Analysis，LDA）两种方式。两者相同之处为均假设数据服从高斯分布，都使用了矩阵分解的思想。两者不同之处为PCA是无监督的算法，对降低后的维度无限制，其目标为投影方差最大；LDA是有监督的算法，降维后的维度小于类别数，其目标为类内方差最小，类间方差最大。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>以上介绍了数据预处理中会用到的大部分方法和技术，完全适用于初学者学习掌握，并且对于实践建模会有大幅度提升。以上方法的代码实现，均可在python的pandas和sklearn中完成。大家可根据需要去查阅学习，网上资料也很多，楼主只提供方法和经验上的借鉴，希望每个认真学习巩固的同学都能得到提升。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TensorFlow </tag>
            
            <tag> 数据处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python中的类</title>
      <link href="/2020/06/02/python/python-zhong-de-lei/"/>
      <url>/2020/06/02/python/python-zhong-de-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="1-新式类和旧式类"><a href="#1-新式类和旧式类" class="headerlink" title="1. 新式类和旧式类"></a>1. 新式类和旧式类</h2><p>这篇文章很好的介绍了新式类的特性: <a href="http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html" target="_blank" rel="noopener">http://www.cnblogs.com/btchenguang/archive/2012/09/17/2689146.html</a></p><p>新式类很早在2.2就出现了,所以旧式类完全是兼容的问题,Python3里的类全部都是新式类.这里有一个MRO问题可以了解下(新式类继承是根据<strong>C3算法</strong>,旧式类是<strong>深度优先</strong>),&lt;Python核心编程&gt;里讲的也很多.</p><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 一个旧式类的深度优先的例子</span><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">foo1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token string">"A"</span><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">foo2</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">foo1</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span> <span class="token string">"C"</span><span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span>d <span class="token operator">=</span> D<span class="token punctuation">(</span><span class="token punctuation">)</span>d<span class="token punctuation">.</span>foo1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># A</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>按照经典类的查找顺序<strong>从左到右深度优先</strong>的规则，在访问<code>d.foo1()</code>的时候,<code>D</code>这个类是没有的..那么往上查找,先找到<code>B</code>,里面没有,深度优先,访问<code>A</code>,找到了<code>foo1()</code>,所以这时候调用的是<code>A</code>的<code>foo1()</code>，从而导致<code>C</code>重写的<code>foo1()</code>被绕过</p></blockquote><h2 id="2-dict-和dir-的区别"><a href="#2-dict-和dir-的区别" class="headerlink" title="2. __dict__和dir()的区别"></a>2. <code>__dict__</code>和<code>dir()</code>的区别</h2><ol><li><p>实例的<code>__dict__</code>仅存储与该实例相关的实例属性，</p><p>正是因为实例的<code>__dict__</code>属性，每个实例的实例属性才会互不影响。</p></li><li><p>类的<code>__dict__</code>存储所有实例共享的变量和函数(类属性，方法等)，类的<strong>dict</strong>并不包含其父类的属性。</p></li><li><p><code>dir()</code>是<code>Python</code>提供的一个API函数，<code>dir()</code>函数会自动寻找一个对象的所有属性(包括从父类中继承的属性)。</p></li></ol><blockquote><p>一个实例的<strong>dict</strong>属性仅仅是那个实例的实例属性的集合，并不包含该实例的所有有效属性。所以如果想获取一个对象所有有效属性，应使用dir()。</p></blockquote><h2 id="3-classmethod-和-staticmethod"><a href="#3-classmethod-和-staticmethod" class="headerlink" title="3. @classmethod 和 @staticmethod"></a>3. <code>@classmethod</code> 和 <code>@staticmethod</code></h2><blockquote><p>类的实例化过程基本遵循</p><ul><li><strong>创建实例对象</strong>、</li><li><strong>初始化实例对象</strong>、</li><li>最后<strong>返回(产生)实例对象</strong></li></ul></blockquote><p><strong>示例</strong></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    data <span class="token operator">=</span> <span class="token string">'world'</span> <span class="token comment" spellcheck="true"># 类对象的数据成员</span>​    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>arg <span class="token operator">=</span> arg​    @staticmethod   <span class="token comment" spellcheck="true"># 静态方法，不能访问类数据成员</span>    <span class="token keyword">def</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span>​    @classmethod    <span class="token comment" spellcheck="true"># 类方法,能访问类数据成员</span>    <span class="token keyword">def</span> <span class="token function">getData</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>cls<span class="token punctuation">.</span>data<span class="token punctuation">)</span>​<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    t <span class="token operator">=</span> Test<span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span>    Test<span class="token punctuation">.</span>func<span class="token punctuation">(</span><span class="token punctuation">)</span>    Test<span class="token punctuation">.</span>getData<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>共同</strong>:   </p><ul><li>两个都是装饰器，装饰的成员函数可以通过类名.方法名(…)来调用</li></ul><p><strong>区别</strong>:</p><ul><li>最显著的特点是<code>classmethod</code>需要传递一个参数<code>cls</code>，而<code>staticmethod</code>不需要。因此可以访问、修改类的属性，类的方法，实例化对象等，避免硬编码；而<code>staticmethod</code>不行</li><li><code>classmethod</code>可以判断出自己是通过基类被调用，还是通过某个子类被调用</li></ul><p><strong>用途</strong>：</p><p><code>classmethod</code>多用于设计模式之<strong>工厂模式</strong>,<u>将解析逻辑封装在方法本身内部</u>。<font color=blue>（也可认为构造前交互，即在进行实例化类对象之前先进行某些逻辑操作，即可看作进行不同的构造函数，然后返回一个类实例</font>，见具体代码）,更多见<code>__new__</code>和<code>__init__</code></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">time</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> year<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span>time<span class="token punctuation">,</span> self<span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>year <span class="token operator">=</span> year        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>year<span class="token punctuation">)</span>​    <span class="token comment" spellcheck="true"># a class method to create a time that one day following the data 'year'</span>    @classmethod    <span class="token keyword">def</span> <span class="token function">tomorrow</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span>year<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># >>> ▲ Python所有类都继承自`&lt;class 'type'>`，包括新式类`object`</span>        <span class="token keyword">return</span> cls<span class="token punctuation">(</span>year<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>​    <span class="token comment" spellcheck="true"># a static method to check whether the given data 'year' is after 2000.</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">twoThoundYear</span><span class="token punctuation">(</span>year<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> year<span class="token operator">></span><span class="token number">2000</span>​t1 <span class="token operator">=</span> time<span class="token punctuation">(</span><span class="token number">1999</span><span class="token punctuation">)</span><span class="token number">1999</span>t2 <span class="token operator">=</span> time<span class="token punctuation">.</span>tomorrow<span class="token punctuation">(</span><span class="token number">1999</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'type'</span><span class="token operator">></span><span class="token number">2000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>staticmethod</code>用法就跟其他的语言中的静态<code>static</code>用法相同（可看作是属于该类的一个工具、辅助函数）</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">m1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"self:"</span><span class="token punctuation">,</span> self<span class="token punctuation">)</span>    @classmethod    <span class="token keyword">def</span> <span class="token function">m2</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"cls:"</span><span class="token punctuation">,</span> cls<span class="token punctuation">)</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">m3</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>m1<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># self: &lt;__main__.A object at 0x000001E596E41A90></span>A<span class="token punctuation">.</span>m2<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># cls: &lt;class '__main__.A'></span>A<span class="token punctuation">.</span>m3<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-1-实例方法"><a href="#3-1-实例方法" class="headerlink" title="3.1. 实例方法"></a>3.1. 实例方法</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>m1<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># A.m1在py2中显示为&lt;unbound method A.m1></span><span class="token operator">&lt;</span>function A<span class="token punctuation">.</span>m1 at <span class="token number">0x000002BF7FF9A488</span><span class="token operator">></span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>m1<span class="token punctuation">)</span><span class="token operator">&lt;</span>bound method A<span class="token punctuation">.</span>m1 of <span class="token operator">&lt;</span>__main__<span class="token punctuation">.</span>A object at <span class="token number">0x000002BF7FFA2BE0</span><span class="token operator">>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>A.m1</code>是一个还没有绑定实例对象的方法，对于未绑定方法，调用 <code>A.m1</code> 时必须显示地传入一个实例对象进去，而 <code>a.m1</code>是已经绑定了实例的方法，<code>python</code>隐式地把对象传递给了<code>self</code>参数，所以不再手动传递参数，这是调用实例方法的过程。</p><pre class="line-numbers language-python"><code class="language-python">A<span class="token punctuation">.</span>m1<span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 等价  </span>a<span class="token punctuation">.</span>m1<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-2-类方法"><a href="#3-2-类方法" class="headerlink" title="3.2. 类方法"></a>3.2. 类方法</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>m2<span class="token punctuation">)</span><span class="token operator">&lt;</span>bound method A<span class="token punctuation">.</span>m2 of <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.A'</span><span class="token operator">>></span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>m2<span class="token punctuation">)</span><span class="token operator">&lt;</span>bound method A<span class="token punctuation">.</span>m2 of <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token string">'__main__.A'</span><span class="token operator">>></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>m2</code>是类方法，不管是<code>A.m2</code>还是 <code>a.m2</code>，都是已经自动绑定了类对象A的方法，对于后者，因为python可以通过实例对象<code>a</code>找到它所属的类是<code>A</code>，找到<code>A</code>之后自动绑定到 <code>cls</code>。</p><pre class="line-numbers language-python"><code class="language-python">A<span class="token punctuation">.</span>m2<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 等价</span>a<span class="token punctuation">.</span>m2<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这使得我们可以在实例方法中通过使用 <code>self.m2()</code>这种方式来调用类方法和静态方法。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">m1</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"self:"</span><span class="token punctuation">,</span> self<span class="token punctuation">)</span>    self<span class="token punctuation">.</span>m2<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-3-静态方法"><a href="#3-3-静态方法" class="headerlink" title="3.3. 静态方法"></a>3.3. 静态方法</h3><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span>m3<span class="token punctuation">)</span><span class="token operator">&lt;</span>function A<span class="token punctuation">.</span>m3 at <span class="token number">0x000002BF7FF9A840</span><span class="token operator">></span><span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>m3<span class="token punctuation">)</span><span class="token operator">&lt;</span>function A<span class="token punctuation">.</span>m3 at <span class="token number">0x000002BF7FF9A840</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>m3</code>是类里面的一个静态方法，跟普通函数没什么区别，与类和实例都没有所谓的绑定关系，它只不过是碰巧存在类中的一个函数而已。不论是通过类还是实例都可以引用该方法。</p><pre class="line-numbers language-python"><code class="language-python">A<span class="token punctuation">.</span>m3<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 等价</span>a<span class="token punctuation">.</span>m3<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="4-new和init的区别"><a href="#4-new和init的区别" class="headerlink" title="4. new和init的区别"></a>4. <strong>new</strong>和<strong>init</strong>的区别</h2><p><strong>知识点</strong></p><ol><li>首先要弄懂<strong>调用顺序</strong><code>__new__--&gt;__init__</code>： 所以<strong>init</strong>其实不是实例化一个类的时候第一个被调用的方法。当使用 <code>Persion(name, age)</code> 这样的表达式来实例化一个类时，最先被调用的方法 其实是<code>__new__</code>方法。<br><code>__new__</code>至少要有一个参数<code>cls</code>，代表要实例化的类，此参数在实例化时由Python解释器自动提供（实例化时加的参数，也会被认为时<code>cls</code>的属性）。即系统知道<code>__new__()</code> 方法始终都是类的类方法，即使没有被加上类方法装饰器。<br><code>__new__</code>方法接受的参数虽然也是和<code>__init__</code>一样，但<code>__init__</code>是<strong>在类实例创建之后调用</strong>，而 <code>__new__</code>方法正是创建这个类实例的方法。</li><li><code>__init__</code>有一个参数<code>self</code>，就是这个<code>__new__</code>中<code>return</code>的实例，<code>__init__</code>在<code>__new__</code>的基础上可以完成一些其它初始化的动作，<code>__init__</code>不需要返回值。而<code>__new__</code>必须有（可以<code>return</code>父类<code>__new__</code>出来的实例，或者直接是<code>object</code>的<code>__new__</code>出来的实例）。<code>__new__</code>方法决定了创建哪个类的实例（可以是父类，也可以是子类），因此不一定调用当前类的<code>__init__</code>。即（若<code>__new__</code>没有正确返回当前类<code>cls</code>的实例，那<code>__init__</code>是不会被调用的，即使是父类的实例也不行）</li><li>继承自<code>object</code>的新式类才有<code>__new__</code>，同时，在任何新式类的<code>__new__()</code>方法，不能调用自身的<code>__new__()</code>来制造实例，因为这会造成死循环，即<code>class Foo(object)</code>的<code>__new__</code>中不能<code>Foo.__new__(cls, *args, **kwargs)</code>。</li></ol><p><strong>区别</strong></p><ol><li><p><code>__init__</code> 通常用于初始化一个新实例，控制这个初始化的过程，比如添加一些属性， 做一些额外的操作，发生在类实例被创建完以后。它是实例级别的方法。</p></li><li><p><code>__new__</code> 通常用于控制生成一个新实例的过程。它是类级别的方法。</p></li></ol><p>依照Python官方文档的说法，<code>__new__</code>方法主要是当你继承一些不可变的<code>class</code>时(比如<code>int, str, tuple</code>)， 提供给你一个自定义这些类的实例化过程的途径。还有就是实现自定义的<code>metaclass</code>。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 新式类:继承自object</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>something<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'init'</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>something<span class="token punctuation">)</span>​    <span class="token comment" spellcheck="true"># def __new__(cls):  不行，因为A("...")参数不匹配</span>    <span class="token comment" spellcheck="true">#     pass</span>​    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'new'</span><span class="token punctuation">)</span>        self <span class="token operator">=</span> object<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># ①cls中包含了*args, **kwargs信息</span>        self<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token string">'1'</span>        <span class="token keyword">return</span> self  <span class="token comment" spellcheck="true"># 调用父类的`__new__`方法会返回一个A对象，init里的参数self调用的就是这个self实例</span>        <span class="token comment" spellcheck="true"># `__new__`必须具有返回值，否则无法创建对象，因为`__init__`函数需要这个返回值</span>        <span class="token comment" spellcheck="true"># 自己在定义`__new__`的时候，参数要与`__init__`函数的参数匹配，我可以不用到这些参数，但一定要匹配。或者可以使用*arg和**args的形式。</span>​<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># a = A.__new__(A) #>>> new</span>    a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token string">'do it'</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># >>> new init do it</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>__dict__<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># {'x': '1'}</span>    <span class="token comment" spellcheck="true"># 2、new定义在type元类中，必须具有返回值，</span>    <span class="token comment" spellcheck="true"># 3、new的作用就是创建实例，然后将创建的实例传递给init进行初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结：</strong><br><code>a = A() --&gt; __new__</code>方法，<code>return</code>调用父类<code>__new__</code>生成一个类实例对象 <code>--&gt;__init__(self,...)</code>中的<code>self</code>实例就是这个父类<code>__new__</code>出来的实例</p><p><code>__new__()</code> 是在新式类中新出现的方法，它作用在构造方法建造实例之前，可以这么理解，在 Python 中存在于类里面的构造方法<code>__init__()</code> 负责将类的实例化，而在<code>__init__()</code> 启动之前，<code>__new__()</code> 决定是否要使用该 <code>__init__()</code> 方法，因为<code>__new__()</code> 可以调用其他类的构造方法或者直接返回别的对象来作为本类的实例。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 代码规范</title>
      <link href="/2019/08/21/python/python-dai-ma-gui-fan/"/>
      <url>/2019/08/21/python/python-dai-ma-gui-fan/</url>
      
        <content type="html"><![CDATA[<p>良好的书写规范有利于我们写出漂亮的代码，也方便以后查看。</p><p>参考文献:  </p><p>\1. PEP 8 – Style Guide for Python Code <a href="https://www.python.org/dev/peps/pep-0008" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008</a>  </p><p>\2. Google开源项目风格指南: <a href="https://zh-google-styleguide.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://zh-google-styleguide.readthedocs.io/en/latest/</a>  </p><p>\3. Python开发规范 <a href="https://www.jianshu.com/p/d414e90dc953" target="_blank" rel="noopener">https://www.jianshu.com/p/d414e90dc953</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 并行处理</title>
      <link href="/2019/08/21/python/python-duo-xian-cheng/"/>
      <url>/2019/08/21/python/python-duo-xian-cheng/</url>
      
        <content type="html"><![CDATA[<p>参考资料:</p><ul><li><a href="https://docs.python.org/2/library/multiprocessing.html?highlight=multipro#" target="_blank" rel="noopener">multiprocessing— Process-based “threading” interface</a>  </li><li><a href="https://python.freelycode.com/contribution/detail/1364" target="_blank" rel="noopener">https://python.freelycode.com/contribution/detail/1364</a></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>并行处理是一种在同一台计算机的多个处理器中同时运行任务的工作模式。 这种工作模式的目的就是减少总的任务处理时间。但是进程之间的通信会有额外的开销，因此对小的任务而言，总的任务时间会有所增加而不是减少。</p><p>在Python语言中，<strong>multiprocessing</strong>模块通过使用子进程（而不是线程）来运行独立的并行进程。 它可以让您利用机器上的多个处理器（Windows和Unix），也就是说，多个进程可以完全独立的在内存中运行。</p><p>学习了本教程的内容之后，您将了解：</p><ul><li>在使用<code>multiprocessing</code>进行并行处理时，如何理解语法并组织代码?  </li><li>如何实现同步和异步并行处理？  </li><li>使用<code>multiprocessing.Pool()</code>接口完成3个不同的用例。  </li></ul><h2 id="可并行的进程数"><a href="#可并行的进程数" class="headerlink" title="可并行的进程数"></a>可并行的进程数</h2><pre class="line-numbers language-bash"><code class="language-bash">lscpu <span class="token comment" spellcheck="true"># 查看cpu详细情况</span><span class="token comment" spellcheck="true"># 获取CPU数目</span><span class="token function">import</span> multiprocessing as mpmp.cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="同步执行和异步执行"><a href="#同步执行和异步执行" class="headerlink" title="同步执行和异步执行"></a>同步执行和异步执行</h2><p>同步执行就是各个进程按照启动的先后，顺序完成。 这是通过锁定主程序直到相应的进程运行完毕来实现的。<br>而异步执行，换句话说，进程的执行不涉及锁定。这样做的结果就是，进程结果返回的顺序可能会混淆，但通常情况下，异步执行会更快完成。</p><p><strong>multiprocessing</strong> 模块中有两个对象是用来实现函数并行执行的：<strong>Pool</strong> 类和<strong>Process</strong> 类。</p><p><strong>Pool 类</strong></p><ul><li>同步执行<ul><li><code>Pool.map()</code> 和 <code>Pool.starmap()</code></li><li><code>Pool.apply()</code></li></ul></li><li>异步执行<ul><li><code>Pool.map_async()</code> 和<code>Pool.starmap_async()</code></li><li><code>Pool.apply_async()</code></li></ul></li></ul><p><strong>Process 类</strong></p><h2 id="问题讨论-计算每行中给定数值范围内的元素个数"><a href="#问题讨论-计算每行中给定数值范围内的元素个数" class="headerlink" title="问题讨论:计算每行中给定数值范围内的元素个数"></a>问题讨论:计算每行中给定数值范围内的元素个数</h2><p>第一个问题：给定一个二维矩阵（或者列表和多维列表），计算每行中给定数值范围内的元素个数。我们可以在下面的列表基础上开始工作。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> time <span class="token keyword">import</span> time<span class="token comment" spellcheck="true">## prepare data</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>RandomState<span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>arr <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span> size<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">20000</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>data <span class="token operator">=</span> arr<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="不使用并行处理的参考代码："><a href="#不使用并行处理的参考代码：" class="headerlink" title="不使用并行处理的参考代码："></a>不使用并行处理的参考代码：</h3><p>我们先看看不用并行计算它需要多长时间。为此，我们对函数<code>howmany_within_range()</code>(如下)进行重复以检查在范围内的数有多少个并返回计数</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">howmany_within_range</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> mini<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> row<span class="token punctuation">:</span>        <span class="token keyword">if</span> mini <span class="token operator">&lt;=</span> n <span class="token operator">&lt;=</span> max<span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> countresult <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> row <span class="token keyword">in</span> data<span class="token punctuation">:</span>    result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>howmany_within_range<span class="token punctuation">(</span>row<span class="token punctuation">,</span> mini<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> max<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如何对函数进行并行化处理"><a href="#如何对函数进行并行化处理" class="headerlink" title="如何对函数进行并行化处理"></a>如何对函数进行并行化处理</h2><p>对代码进行并行处理通常的做法是取出其中可以多次运行的特定函数，将其放在不同的处理器上并行运行。</p><p>要做到这一点，就需要使用 <strong>Pool类</strong>对数目为n的处理器进行初始化，之后将想要并行运行的函数传递给<strong>Pool类</strong>中的并行方法。</p><p><strong>multiprocessing.Pool()</strong> 中提供了 <strong>apply()</strong>, <strong>map()</strong> 和 <strong>starmap()</strong> 等方法对传入的函数并行运行。</p><p>这简直太完美了！那么<strong>apply</strong>()和 <strong>map()</strong>之间又有什么区别呢？</p><p><code>apply()</code>和 <code>map()</code>都是把要进行并行化的函数作为主要参数。但是<strong>不同的是，</strong> <code>apply()</code>接受<code>args</code>参数， 通过args将各个参数传送给被并行化处理的函数，而<code>map</code> 仅将一个迭代器作为参数。</p><p>因此，对于简单的可迭代的操作，使用map()进行并行处理更适合，而且能更快完成工作。</p><p>当我们看到如何使用<code>apply()</code>和<code>map()</code>对函数<code>howmany_within_range()</code>进行并行化处理之后，我们还会介绍<code>starmap()</code>。</p><h3 id="Pool-apply-进行并行化处理"><a href="#Pool-apply-进行并行化处理" class="headerlink" title="Pool.apply() 进行并行化处理"></a>Pool.apply() 进行并行化处理</h3><p>我们来使用<code>multiprocessing.Pool()</code>，对<code>howmany_within_range()</code> 函数进行并行化处理。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mp<span class="token comment" spellcheck="true"># Step 1. Init multiprocessing.Pool()</span>pool <span class="token operator">=</span>mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>mp<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> <span class="token punctuation">[</span>pool<span class="token punctuation">.</span>apply<span class="token punctuation">(</span>howmany_within_range<span class="token punctuation">,</span>     args<span class="token operator">=</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> data<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Step 3. Don't forget to close</span>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Parallelizing-using-Pool-map"><a href="#Parallelizing-using-Pool-map" class="headerlink" title="Parallelizing using Pool.map()"></a>Parallelizing using Pool.map()</h3><p><code>Pool.map()</code>仅接受一个迭代器参数。 为了变通起见，我把<code>howmany_within_range</code>函数做了修改，为 <code>minimum</code> 和 <code>maximum</code>参数设定了缺省值，并另存为新的函数 <code>howmany_within_range_rowonly()</code>，这个函数可以只接受行数据列表迭代器作为输入。我知道这种做法不是<code>map()</code>的一个最好的用法，但它已经清楚地显示出它与<code>apply()</code>的不同之处。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mp<span class="token comment" spellcheck="true"># Redefine, with only 1 mandatory argument.</span><span class="token keyword">def</span> <span class="token function">howmany_within_range_rowonly</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> mini<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">,</span> max<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> row<span class="token punctuation">:</span>        <span class="token keyword">if</span> mini <span class="token operator">&lt;=</span> n <span class="token operator">&lt;=</span> max<span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> countpool <span class="token operator">=</span>mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>mp<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> pool<span class="token punctuation">.</span>map<span class="token punctuation">(</span>    howmany_within_range_rowonly<span class="token punctuation">,</span>     <span class="token punctuation">[</span>row <span class="token keyword">for</span> row <span class="token keyword">in</span> data<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Step 3. Don't forget to close</span>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用Pool-starmap-进行并行化"><a href="#使用Pool-starmap-进行并行化" class="headerlink" title="使用Pool.starmap() 进行并行化"></a>使用Pool.starmap() 进行并行化</h3><p>在前面的例子中，我们必须重新定义<code>howmany_within_range</code>函数，让其中的一对参数使用默认值。 而使用starmap()，您就能避免这样做。 你怎么问？</p><p>与<code>Pool.map</code>()一样，<code>Pool.starmap()</code>也只仅接受一个迭代器参数，但在<code>starmap()</code>中，迭代器种的每一个元件也是一个迭代器。你可以通过这个内部迭代器向被并行化处理的函数传递参数，在执行时再顺序解开，只要传递和解开的顺序一致就可以。</p><p>实际上，<code>Pool.starmap()</code>就像是一个接受参数的<code>Pool.map()</code>版本。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mppool <span class="token operator">=</span>mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>mp<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> pool<span class="token punctuation">.</span>starmap<span class="token punctuation">(</span>howmany_within_range<span class="token punctuation">,</span>     <span class="token punctuation">[</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">for</span> row <span class="token keyword">in</span> data<span class="token punctuation">]</span><span class="token punctuation">)</span>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="异步并行处理"><a href="#异步并行处理" class="headerlink" title="异步并行处理"></a>异步并行处理</h2><p>和同步并行处理对等的异步并行处理函数 <code>apply_async()</code>，<code>map_async()</code>和<code>starmap_async()</code>允许您以异步方式并行执行进程，即下一个进程可以在前一个进程完成时立即启动，而不考虑启动顺序。 因此，无法保证结果与输入的顺序相同。</p><h3 id="使用Pool-apply-async-进行并行化"><a href="#使用Pool-apply-async-进行并行化" class="headerlink" title="使用Pool.apply_async()进行并行化"></a>使用Pool.apply_async()进行并行化</h3><p><code>apply_async()</code>的使用与<code>apply()</code>非常相似，只是你需要提供一个回调函数来告诉如何存储计算结果。</p><p>但是，使用<code>apply_async()</code>时需要注意的是，结果中的数字顺序会混乱，表明进程没有按照启动的顺序完成。</p><p>变通的办法就是，我们重新定义一个新的<code>howmany_within_range2()</code>，接受并返回迭代序号（i），然后对最终结果进行排序。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mppool <span class="token operator">=</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>mp<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># Step 1: Redefine, to accept 'i', the iteration number</span><span class="token keyword">def</span> <span class="token function">howmany_within_range2</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> row<span class="token punctuation">,</span> mini<span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token punctuation">:</span>    count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> row<span class="token punctuation">:</span>        <span class="token keyword">if</span> mini <span class="token operator">&lt;=</span> n <span class="token operator">&lt;=</span> max<span class="token punctuation">:</span>            count <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Step 2: Define callback function to collect the output in 'results'</span><span class="token keyword">def</span> <span class="token function">collect_results</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> results    results<span class="token punctuation">.</span>append<span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Step 3: Use loop to parallelize</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> row <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>    pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>        howmany_within_range2<span class="token punctuation">,</span>        args<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> row<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        callback<span class="token operator">=</span>collect_results    <span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Step 4: Close Pool and let all the processes complete</span>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>pool<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># postpones the excution of next line of code until all processes in the queue are done</span><span class="token comment" spellcheck="true"># Step 5: Sort results [OPTIONAL]</span>results<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>results_final <span class="token operator">=</span> <span class="token punctuation">[</span>r <span class="token keyword">for</span> i<span class="token punctuation">,</span>r <span class="token keyword">in</span> results<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用<code>apply_async()</code>时，不提供回调函数也是可以的。只是这时候，如果您不提供回调函数，那么您将获得<code>pool.ApplyResult</code>对象的列表，其中包含来自每个进程的计算输出值。 从这里，您需要使用<code>pool.ApplyResult.get()</code>方法来得到所需的最终结果。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mppool <span class="token operator">=</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>mp<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># call apply_async() without callback</span>result_objects <span class="token operator">=</span> <span class="token punctuation">[</span>pool<span class="token punctuation">.</span>apply_async<span class="token punctuation">(</span>    howmany_within_range2<span class="token punctuation">,</span>    args <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> row<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i<span class="token punctuation">,</span>row <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># result_objects is a list of pool.ApplyResult objects</span>results <span class="token operator">=</span> <span class="token punctuation">[</span>r<span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">for</span> r <span class="token keyword">in</span> result_objects<span class="token punctuation">]</span>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>pool<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用Pool-starmap-async-进行并行化"><a href="#使用Pool-starmap-async-进行并行化" class="headerlink" title="使用Pool.starmap_async()进行并行化"></a>使用Pool.starmap_async()进行并行化</h3><p>你已经见识了<code>apply_async()</code>的使用。你是否可以想象一下或者写一个 <code>starmap_async and map_async</code>的对应版本呢？  实现代码如下：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mppool <span class="token operator">=</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span>mp<span class="token punctuation">.</span>cpu_count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>results <span class="token operator">=</span> pool<span class="token punctuation">.</span>starmap_async<span class="token punctuation">(</span>    howmany_within_range2<span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>row<span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token keyword">for</span> i<span class="token punctuation">,</span>row <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span>get<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># with map, use 'howmany_within_range_rowonly' instead results = pool.map_async(howmany_within_range_rowonly, [row for row in data]).get()</span>pool<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>results<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="如何对Pandas-DataFrame进行并行处理？"><a href="#如何对Pandas-DataFrame进行并行处理？" class="headerlink" title="如何对Pandas DataFrame进行并行处理？"></a>如何对Pandas DataFrame进行并行处理？</h2><p>到目前为止，您已经了解了如何通过使函数在列表上工作来进行函数并行化。</p><p>但是，在处理数据分析或机器学习项目时，您可能希望对<code>Pandas Dataframe</code> 进行并行化，<code>Pandas Dataframe</code>是除了<code>numpy</code>数组之外，最常用的存储表格数据对象。</p><p>在对<code>DataFrame</code>进行并行化时，您可以把要被并行化的函数作为输入参数：</p><ul><li><code>DataFrame</code>的一行</li><li><code>DataFrame</code>的一列</li><li>整个<code>DataFrame</code></li></ul><p>前两个可以使用<code>multiprocessing</code>本身就可以完成。 但是对于最后一个，即对整个<code>dataframe</code>进行并行化，我们将使用<code>pathos</code>包，<code>pathos</code>包内部使用了<code>dill</code>进行序列化。</p><p>首先，让我们创建一个简单的<code>dataframe</code>，看看如何进行逐行和逐列进行并行化。 在用户定义的函数种使用了类似<code>pd.apply()</code>的写法，但这是并行处理。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd<span class="token keyword">import</span> multiprocessing <span class="token keyword">as</span> mpdf <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span>size<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>df<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在已经有了<code>dataframe</code>。之后使用<code>hypotenuse</code>对每一行进行处理，每次同时运行4个进程。</p><p>为了做到这一点，在下面的代码中，可以看到我们使用了<code>df.itertuples(name=False)</code>。设定<code>name=False</code>， 就可以把<code>dataframe</code>中的每一行作为一个简单的元组送入<code>hypotenuse</code>函数</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">hypotenuse</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> round<span class="token punctuation">(</span>row<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> row<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">**</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">0.5</span><span class="token keyword">with</span> mp<span class="token punctuation">.</span>Pool<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token keyword">as</span> pool<span class="token punctuation">:</span>    result <span class="token operator">=</span> pool<span class="token punctuation">.</span>imap<span class="token punctuation">(</span>        hypotenuse<span class="token punctuation">,</span> df<span class="token punctuation">.</span>itertuples<span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">,</span> chunked<span class="token operator">=</span><span class="token number">10</span>    <span class="token punctuation">)</span>    output <span class="token operator">=</span> <span class="token punctuation">[</span>round<span class="token punctuation">(</span>x<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> result<span class="token punctuation">]</span><span class="token keyword">print</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并行 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>画图相关</title>
      <link href="/2019/08/07/python/matplotlib/"/>
      <url>/2019/08/07/python/matplotlib/</url>
      
        <content type="html"><![CDATA[<h2 id="图片中字体问题"><a href="#图片中字体问题" class="headerlink" title="图片中字体问题"></a>图片中字体问题</h2><pre class="line-numbers language-python"><code class="language-python">plt<span class="token punctuation">.</span>rc<span class="token punctuation">(</span><span class="token string">'text'</span><span class="token punctuation">,</span> <span class="token operator">*</span>usetex<span class="token operator">*=</span><span class="token boolean">True</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>rc<span class="token punctuation">(</span><span class="token string">'font'</span><span class="token punctuation">,</span> <span class="token operator">*</span>family<span class="token operator">*=</span><span class="token string">'serif'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.size'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">15</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="多线条颜色设置"><a href="#多线条颜色设置" class="headerlink" title="多线条颜色设置"></a>多线条颜色设置</h2><pre class="line-numbers language-python"><code class="language-python">colors <span class="token operator">=</span> plt<span class="token punctuation">.</span>get_cmap<span class="token punctuation">(</span><span class="token string">'brg'</span><span class="token punctuation">)</span><span class="token punctuation">(</span>np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="eps-不透明度"><a href="#eps-不透明度" class="headerlink" title="eps 不透明度"></a>eps 不透明度</h2><p>先保存pdf再转eps</p><pre class="line-numbers language-bash"><code class="language-bash">pdftops -eps name.pdf name.eps<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matplotlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python正则表达</title>
      <link href="/2019/06/03/python/python-zheng-zai-biao-da/"/>
      <url>/2019/06/03/python/python-zheng-zai-biao-da/</url>
      
        <content type="html"><![CDATA[<h2 id="非打印字符"><a href="#非打印字符" class="headerlink" title="非打印字符"></a>非打印字符</h2><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>\cx</td><td>Control+x,x属于[A-Z a-z]</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\s</td><td>任何空白字符，包括空格、制表符、换页符等，等价于[\f\n\r\t\v]</td></tr><tr><td>\S</td><td>任何非空白字符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\r</td><td>回车符</td></tr></tbody></table><h2 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h2><p>放到匹配字符的后边，有特殊的含义，要相匹配他们要加反斜杠转义</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>$</td><td>输入字符串的结尾位置，特殊的：\n \r</td></tr><tr><td>( )</td><td>标记一个子表达式的开始和结束位置</td></tr><tr><td>*</td><td>前面的子表达式零次或多次</td></tr><tr><td>+</td><td>前面的子表达式一次或多次</td></tr><tr><td>.</td><td>除换行符 \n 之外的任何单字符</td></tr><tr><td>[ ]</td><td>标记一个中括号表达式</td></tr><tr><td>?</td><td>前面的子表达式零次或一次，非贪婪的，尽可能匹配短的</td></tr><tr><td>\</td><td>转义</td></tr><tr><td>^</td><td>输入字符串的开始位，特殊的：\n \r</td></tr><tr><td>{ }</td><td>限定符表达式的开始</td></tr><tr><td></td><td>指明两项之间的一个选择</td></tr></tbody></table><h2 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h2><p>指定正则表达式的一个给定组件必须要出现多少次才能满足匹配</p><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>前面的子表达式零次或多次</td></tr><tr><td>+</td><td>前面的子表达式一次或多次</td></tr><tr><td>?</td><td>前面的子表达式零次或一次</td></tr><tr><td>{n}</td><td>匹配确定的 n 次</td></tr><tr><td>{n,}</td><td>至少匹配n 次</td></tr><tr><td>{n,m}</td><td>最少匹配 n 次且最多匹配 m 次</td></tr></tbody></table><h2 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h2><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>输入字符串的开始位，特殊的：\n \r</td></tr><tr><td>$</td><td>输入字符串的结尾位置，特殊的：\n \r</td></tr><tr><td>\b</td><td>匹配一个单词边界，即字与空格间的位置</td></tr><tr><td>\B</td><td>非单词边界匹配</td></tr></tbody></table><h2 id="其他的元字符"><a href="#其他的元字符" class="headerlink" title="其他的元字符"></a>其他的元字符</h2><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>(pattern)</td><td>匹配 pattern 并获取这一匹配</td></tr><tr><td>(?:pattern)</td><td>匹配 pattern 但不获取匹配结果</td></tr><tr><td>(?=pattern)</td><td>正向肯定预查</td></tr><tr><td>(?!pattern)</td><td>正向否定预查</td></tr><tr><td>(?&lt;=pattern)</td><td>反向肯定预查，与正向肯定预查类似，只是方向相反</td></tr><tr><td>(?&lt;!pattern)</td><td>反向否定预查，与正向否定预查类似，只是方向相反</td></tr><tr><td>x</td><td>y</td></tr><tr><td>[xyz]</td><td>字符集合，匹配所包含的任意一个字符</td></tr><tr><td>[^xyz</td><td>负值字符集合，匹配未包含的任意字符</td></tr><tr><td>[a-z]</td><td>字符范围，匹配指定范围内的任意字符</td></tr><tr><td>[^a-z]</td><td>负值字符范围，匹配任何不在指定范围内的任意字符</td></tr><tr><td>\d</td><td>匹配一个数字字符，等价于 [0-9]</td></tr><tr><td>\D</td><td>匹配一个非数字字符，等价于 [^0-9]</td></tr><tr><td>\w</td><td>匹配字母、数字、下划线,等价于 [A-Za-z0-9_]</td></tr><tr><td>\W</td><td>与\w相反，等价于 [^A-Za-z0-9_]</td></tr><tr><td>\num</td><td>匹配num个，其中 num 是一个正整数，对所获取的匹配的引用。如，’(.)\1’ 匹配两个连续的相同字符。</td></tr></tbody></table><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>优先级相同的从左到右运算</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>转义符</td></tr><tr><td>()[]</td><td>括号</td></tr><tr><td>* , +, ?, {n}, {n,}, {n,m}</td><td>限定符</td></tr><tr><td>^, $, \任何元字符、任何字符</td><td>位置和序列</td></tr><tr><td>|</td><td>或</td></tr></tbody></table><h2 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h2><ul><li>数字：<code>^[0-9]*$</code></li><li>n位的数字：<code>^\d{n}$</code></li><li>至少n位的数字：<code>^\d{n,}$</code></li><li>m-n位的数字：<code>^\d{m,n}$</code></li><li>零和非零开头的数字：<code>^(0|[1-9][0-9]*)$</code></li><li>非零开头的最多带两位小数的数字：<code>^([1-9][0-9]*)+(.[0-9]{1,2})?$</code></li><li>带1-2位小数的正数或负数：<code>^(\-)?\d+(\.\d{1,2})?$</code></li><li>正数、负数、和小数：<code>^(\-|\+)?\d+(\.\d+)?$</code></li><li>有两位小数的正实数：<code>^[0-9]+(.[0-9]{2})?$</code></li><li>有1~3位小数的正实数：<code>^[0-9]+(.[0-9]{1,3})?$</code></li><li>非零的正整数：<code>^[1-9]\d*$</code> 或 <code>^([1-9][0-9]*){1,3}$</code> 或 <code>^\+?[1-9][0-9]*$</code></li><li>非零的负整数：<code>^\-[1-9][]0-9″*$</code> 或 <code>^-[1-9]\d*$</code></li><li>非负整数：<code>^\d+$</code> 或 <code>^[1-9]\d*|0$</code></li><li>非正整数：<code>^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$</code></li><li>非负浮点数：<code>^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$</code></li><li><code>非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$</code></li><li>正浮点数：<code>^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$</code> 或 <code>^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$</code></li><li>负浮点数：<code>^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)</code>$ 或 <code>^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$</code></li><li>浮点数：<code>^(-?\d+)(\.\d+)?$</code> 或 <code>^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$</code></li></ul><h2 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h2><ul><li>汉字：<code>^[\u4e00-\u9fa5]{0,}$</code></li><li>英文和数字：<code>^[A-Za-z0-9]+$</code> 或 <code>^[A-Za-z0-9]{4,40}$</code></li><li>长度为3-20的所有字符：<code>^.{3,20}$</code></li><li>由26个英文字母组成的字符串：<code>^[A-Za-z]+$</code></li><li>由26个大写英文字母组成的字符串：<code>^[A-Z]+$</code></li><li>由26个小写英文字母组成的字符串：<code>^[a-z]+$</code></li><li>由数字和26个英文字母组成的字符串：<code>^[A-Za-z0-9]+$</code></li><li>由数字、26个英文字母或者下划线组成的字符串：<code>^\w+$</code> 或 <code>^\w{3,20}$</code></li><li>中文、英文、数字包括下划线：<code>^[\u4E00-\u9FA5A-Za-z0-9_]+$</code></li><li>中文、英文、数字但不包括下划线等符号：<code>^[\u4E00-\u9FA5A-Za-z0-9]+$</code> 或 <code>^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$</code></li><li>可以输入含有<code>^%&amp;’,;=?$\”</code>等字符：<code>[^%&amp;&#39;,;=?$\x22]+</code></li><li>禁止输入含有<del>的字符：`[^</del>\x22]+`</li></ul><h2 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h2><ul><li>Email地址：<code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></li><li>域名：<code>[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?</code></li><li>InternetURL：<code>[a-zA-z]+://[^\s]*</code> 或 <code>^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</code></li><li>手机号码：<code>^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$</code></li><li>电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：<code>^($$\d{3,4}-)|\d{3.4}-)?\d{7,8}$</code></li><li>国内电话号码(0511-4405222、021-87888822)：<code>\d{3}-\d{8}|\d{4}-\d{7}</code></li><li>身份证号(15位、18位数字)：<code>^\d{15}|\d{18}$</code></li><li>短身份证号码(数字、字母x结尾)：<code>^([0-9]){7,18}(x|X)?$</code> 或 <code>^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$</code></li><li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：<code>^[a-zA-Z][a-zA-Z0-9_]{4,15}$</code></li><li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：<code>^[a-zA-Z]\w{5,17}$</code></li><li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：<code>^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$</code></li><li>日期格式：<code>^\d{4}-\d{1,2}-\d{1,2}</code></li><li>一年的12个月(01～09和1～12)：<code>^(0?[1-9]|1[0-2])$</code></li><li>一个月的31天(01～09和1～31)：<code>^((0?[1-9])|((1|2)[0-9])|30|31)$</code></li><li>钱的输入格式：<ul><li>有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：<code>^[1-9][0-9]*$</code></li><li>这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：<code>^(0|[1-9][0-9]*)$</code></li><li>一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：<code>^(0|-?[1-9][0-9]*)$</code></li><li>这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：<code>^[0-9]+(.[0-9]+)?$</code></li><li>必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：<code>^[0-9]+(.[0-9]{2})?$</code></li><li>这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：<code>^[0-9]+(.[0-9]{1,2})?$</code></li><li>这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：<code>^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$</code></li><li>1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：<code>^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$</code></li><li>备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里</li></ul></li><li>xml文件：<code>^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$</code></li><li>中文字符的正则表达式：<code>[\u4e00-\u9fa5]</code></li><li>双字节字符：<code>[^\x00-\xff]</code> (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))</li><li>空白行的正则表达式：<code>\n\s*\r</code> (可以用来删除空白行)</li><li>HTML标记的正则表达式：<code>&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</code> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)</li><li>首尾空白字符的正则表达式：<code>^\s*|\s*$或(^\s*)|(\s*$)</code> (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)</li><li>腾讯QQ号：<code>[1-9][0-9]{4,}</code> (腾讯QQ号从10000开始)</li><li>中国邮政编码：<code>[1-9]\d{5}(?!\d)</code> (中国邮政编码为6位数字)</li><li>IP地址：<code>\d+\.\d+\.\d+\.\d+</code> (提取IP地址时有用)</li><li>IP地址：<code>((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))</code> </li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python中的单例模式</title>
      <link href="/2019/06/01/python/python-zhong-de-dan-li-mo-shi/"/>
      <url>/2019/06/01/python/python-zhong-de-dan-li-mo-shi/</url>
      
        <content type="html"><![CDATA[<blockquote><p>单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</p><p><code>__new__()</code>在<code>__init__()</code>之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例<br><strong>这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.</strong></p></blockquote><ol><li>利用<code>staticmethod</code></li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    instance <span class="token operator">=</span> None    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> SyntaxError<span class="token punctuation">(</span><span class="token string">'can not instance, please use get_instance'</span><span class="token punctuation">)</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> Singleton<span class="token punctuation">.</span>instance <span class="token keyword">is</span> None<span class="token punctuation">:</span>            Singleton<span class="token punctuation">.</span>instance <span class="token operator">=</span> object<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span>        <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>instancea <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>get_instance<span class="token punctuation">(</span><span class="token punctuation">)</span>b <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>get_instance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'a id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># a id= 4543445392</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'b id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># b id= 4543445392</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法的要点是在<code>__init__</code>抛出异常，禁止通过类来实例化，只能通过静态<code>get_instance</code>函数来获取实例；因为不能通过类来实例化，所以静态<code>get_instance</code>函数中可以通过父类<code>object.__new__</code>来实例化。</p><p>缺点： 实例化都要先调用静态方法，而且每次实例化都要调用。</p><p>若要避免每次实例化，重新调用，可以在添加一个<code>__init_flag</code>属性。</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    instance <span class="token operator">=</span> None    __init_flag <span class="token operator">=</span> <span class="token boolean">True</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> __init_flag <span class="token operator">==</span> <span class="token boolean">True</span><span class="token punctuation">:</span>            <span class="token keyword">raise</span> SyntaxError<span class="token punctuation">(</span><span class="token string">'can not instance, please use get_instance'</span><span class="token punctuation">)</span>            __init_flag <span class="token operator">=</span> <span class="token boolean">False</span>    @staticmethod    <span class="token keyword">def</span> <span class="token function">get_instance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> Singleton<span class="token punctuation">.</span>instance <span class="token keyword">is</span> None<span class="token punctuation">:</span>            Singleton<span class="token punctuation">.</span>instance <span class="token operator">=</span> object<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span>        <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>instancea <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>get_instance<span class="token punctuation">(</span><span class="token punctuation">)</span>b <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>get_instance<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'a id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># a id= 4543445392</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'b id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># b id= 4543445392</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><code>classmethod</code></li></ol><p>和方法一类似，代码：</p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    instance <span class="token operator">=</span> None    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> SyntaxError<span class="token punctuation">(</span><span class="token string">'can not instance, please use get_instance'</span><span class="token punctuation">)</span>     @classmethod    <span class="token keyword">def</span> <span class="token function">get_instance</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> Singleton<span class="token punctuation">.</span>instance <span class="token keyword">is</span> None<span class="token punctuation">:</span>            Singleton<span class="token punctuation">.</span>instance <span class="token operator">=</span> object<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 这样不可以实例化 c = Singleton 会报错，可以修改这一行和注释掉__init__中的raise SytaxError</span>        <span class="token keyword">return</span> Singleton<span class="token punctuation">.</span>instance <span class="token comment" spellcheck="true"># 若要添加属性，返回Singleton或者cls即可，属性就会被添加进去</span>a <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>get_instance<span class="token punctuation">(</span><span class="token punctuation">)</span>b <span class="token operator">=</span> Singleton<span class="token punctuation">.</span>get_instance<span class="token punctuation">(</span><span class="token punctuation">)</span>c <span class="token operator">=</span> Singleton<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'a id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># a id= 4558530128</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'b id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># b id= 4558530128</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'b id='</span><span class="token punctuation">,</span> id<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># c id= 4558530704</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该方法的要点是在<code>__init__</code>抛出异常，禁止通过类来实例化，只能通过静态<code>get_instance</code>函数来获取实例；因为不能通过类来实例化，所以静态<code>get_instance</code>函数中可以通过父类<code>object.__new__</code>来实例化。</p><p>缺点同上，且只能在<code>get_instance</code>方法中实现，实例化<code>c = Singleton()</code>与<code>a = Singleton.get_instance()</code>的<code>id</code>不同</p><ol start="3"><li>使用<code>__new__</code>方法</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> hasattr<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token string">'_instance'</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            orig <span class="token operator">=</span> super<span class="token punctuation">(</span>Singleton<span class="token punctuation">,</span> cls<span class="token punctuation">)</span>            cls<span class="token punctuation">.</span>_instance <span class="token operator">=</span> orig<span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>        <span class="token keyword">return</span> cls<span class="token punctuation">.</span>_instance<span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span>Singleton<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>共享属性<br>创建实例时把所有实例的<code>__dict__</code>指向同一个字典,这样它们具有相同的属性和方法.</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Borg</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    _state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">def</span> <span class="token function">__new__</span><span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>        ob <span class="token operator">=</span> super<span class="token punctuation">(</span>Borg<span class="token punctuation">,</span> cls<span class="token punctuation">)</span><span class="token punctuation">.</span>__new__<span class="token punctuation">(</span>cls<span class="token punctuation">,</span> <span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>        ob<span class="token punctuation">.</span>__dict__ <span class="token operator">=</span> cls<span class="token punctuation">.</span>_state        <span class="token keyword">return</span> ob<span class="token keyword">class</span> <span class="token class-name">MyClass2</span><span class="token punctuation">(</span>Borg<span class="token punctuation">)</span><span class="token punctuation">:</span>    a <span class="token operator">=</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>装饰器版本</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">singleton</span><span class="token punctuation">(</span>cls<span class="token punctuation">)</span><span class="token punctuation">:</span>    instances <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">def</span> <span class="token function">getinstance</span><span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> cls <span class="token operator">not</span> <span class="token keyword">in</span> instances<span class="token punctuation">:</span>            instances<span class="token punctuation">[</span>cls<span class="token punctuation">]</span> <span class="token operator">=</span> cls<span class="token punctuation">(</span><span class="token operator">*</span>args<span class="token punctuation">,</span> <span class="token operator">**</span>kw<span class="token punctuation">)</span>        <span class="token keyword">return</span> instances<span class="token punctuation">[</span>cls<span class="token punctuation">]</span>    <span class="token keyword">return</span> getinstance@singleton<span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">:</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="6"><li><code>import</code>方法<br>作为python的模块是天然的单例模式</li></ol><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 5. mysingleton.py</span><span class="token keyword">class</span> <span class="token class-name">My_Singleton</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span>my_singleton <span class="token operator">=</span> My_Singleton<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 6. to use</span><span class="token keyword">from</span> mysingleton <span class="token keyword">import</span> my_singletonmy_singleton<span class="token punctuation">.</span>foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
